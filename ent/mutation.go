// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/lbrictson/janus/ent/authconfig"
	"github.com/lbrictson/janus/ent/dataconfig"
	"github.com/lbrictson/janus/ent/job"
	"github.com/lbrictson/janus/ent/jobconfig"
	"github.com/lbrictson/janus/ent/jobhistory"
	"github.com/lbrictson/janus/ent/notificationchannel"
	"github.com/lbrictson/janus/ent/predicate"
	"github.com/lbrictson/janus/ent/project"
	"github.com/lbrictson/janus/ent/projectuser"
	"github.com/lbrictson/janus/ent/schema"
	"github.com/lbrictson/janus/ent/secret"
	"github.com/lbrictson/janus/ent/smtpconfig"
	"github.com/lbrictson/janus/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAudit               = "Audit"
	TypeAuthConfig          = "AuthConfig"
	TypeDataConfig          = "DataConfig"
	TypeJob                 = "Job"
	TypeJobConfig           = "JobConfig"
	TypeJobHistory          = "JobHistory"
	TypeNotificationChannel = "NotificationChannel"
	TypeProject             = "Project"
	TypeProjectUser         = "ProjectUser"
	TypeSMTPConfig          = "SMTPConfig"
	TypeSecret              = "Secret"
	TypeUser                = "User"
)

// AuditMutation represents an operation that mutates the Audit nodes in the graph.
type AuditMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Audit, error)
	predicates    []predicate.Audit
}

var _ ent.Mutation = (*AuditMutation)(nil)

// auditOption allows management of the mutation configuration using functional options.
type auditOption func(*AuditMutation)

// newAuditMutation creates new mutation for the Audit entity.
func newAuditMutation(c config, op Op, opts ...auditOption) *AuditMutation {
	m := &AuditMutation{
		config:        c,
		op:            op,
		typ:           TypeAudit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditID sets the ID field of the mutation.
func withAuditID(id int) auditOption {
	return func(m *AuditMutation) {
		var (
			err   error
			once  sync.Once
			value *Audit
		)
		m.oldValue = func(ctx context.Context) (*Audit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Audit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAudit sets the old Audit of the mutation.
func withAudit(node *Audit) auditOption {
	return func(m *AuditMutation) {
		m.oldValue = func(context.Context) (*Audit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Audit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the AuditMutation builder.
func (m *AuditMutation) Where(ps ...predicate.Audit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Audit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Audit).
func (m *AuditMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Audit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Audit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Audit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Audit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Audit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Audit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Audit edge %s", name)
}

// AuthConfigMutation represents an operation that mutates the AuthConfig nodes in the graph.
type AuthConfigMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	enable_sso             *bool
	disable_password_login *bool
	sso_provider           *string
	sso_client_id          *string
	sso_client_secret      *string
	sso_redirect_uri       *string
	sso_authorization_url  *string
	sso_token_url          *string
	sso_user_info_url      *string
	entra_tenant_id        *string
	google_allowed_domains *string
	session_key            *[]byte
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*AuthConfig, error)
	predicates             []predicate.AuthConfig
}

var _ ent.Mutation = (*AuthConfigMutation)(nil)

// authconfigOption allows management of the mutation configuration using functional options.
type authconfigOption func(*AuthConfigMutation)

// newAuthConfigMutation creates new mutation for the AuthConfig entity.
func newAuthConfigMutation(c config, op Op, opts ...authconfigOption) *AuthConfigMutation {
	m := &AuthConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthConfigID sets the ID field of the mutation.
func withAuthConfigID(id int) authconfigOption {
	return func(m *AuthConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthConfig
		)
		m.oldValue = func(ctx context.Context) (*AuthConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthConfig sets the old AuthConfig of the mutation.
func withAuthConfig(node *AuthConfig) authconfigOption {
	return func(m *AuthConfigMutation) {
		m.oldValue = func(context.Context) (*AuthConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthConfigMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnableSSO sets the "enable_sso" field.
func (m *AuthConfigMutation) SetEnableSSO(b bool) {
	m.enable_sso = &b
}

// EnableSSO returns the value of the "enable_sso" field in the mutation.
func (m *AuthConfigMutation) EnableSSO() (r bool, exists bool) {
	v := m.enable_sso
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableSSO returns the old "enable_sso" field's value of the AuthConfig entity.
// If the AuthConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthConfigMutation) OldEnableSSO(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableSSO is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableSSO requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableSSO: %w", err)
	}
	return oldValue.EnableSSO, nil
}

// ResetEnableSSO resets all changes to the "enable_sso" field.
func (m *AuthConfigMutation) ResetEnableSSO() {
	m.enable_sso = nil
}

// SetDisablePasswordLogin sets the "disable_password_login" field.
func (m *AuthConfigMutation) SetDisablePasswordLogin(b bool) {
	m.disable_password_login = &b
}

// DisablePasswordLogin returns the value of the "disable_password_login" field in the mutation.
func (m *AuthConfigMutation) DisablePasswordLogin() (r bool, exists bool) {
	v := m.disable_password_login
	if v == nil {
		return
	}
	return *v, true
}

// OldDisablePasswordLogin returns the old "disable_password_login" field's value of the AuthConfig entity.
// If the AuthConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthConfigMutation) OldDisablePasswordLogin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisablePasswordLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisablePasswordLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisablePasswordLogin: %w", err)
	}
	return oldValue.DisablePasswordLogin, nil
}

// ResetDisablePasswordLogin resets all changes to the "disable_password_login" field.
func (m *AuthConfigMutation) ResetDisablePasswordLogin() {
	m.disable_password_login = nil
}

// SetSSOProvider sets the "sso_provider" field.
func (m *AuthConfigMutation) SetSSOProvider(s string) {
	m.sso_provider = &s
}

// SSOProvider returns the value of the "sso_provider" field in the mutation.
func (m *AuthConfigMutation) SSOProvider() (r string, exists bool) {
	v := m.sso_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldSSOProvider returns the old "sso_provider" field's value of the AuthConfig entity.
// If the AuthConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthConfigMutation) OldSSOProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSSOProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSSOProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSOProvider: %w", err)
	}
	return oldValue.SSOProvider, nil
}

// ResetSSOProvider resets all changes to the "sso_provider" field.
func (m *AuthConfigMutation) ResetSSOProvider() {
	m.sso_provider = nil
}

// SetSSOClientID sets the "sso_client_id" field.
func (m *AuthConfigMutation) SetSSOClientID(s string) {
	m.sso_client_id = &s
}

// SSOClientID returns the value of the "sso_client_id" field in the mutation.
func (m *AuthConfigMutation) SSOClientID() (r string, exists bool) {
	v := m.sso_client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSSOClientID returns the old "sso_client_id" field's value of the AuthConfig entity.
// If the AuthConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthConfigMutation) OldSSOClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSSOClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSSOClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSOClientID: %w", err)
	}
	return oldValue.SSOClientID, nil
}

// ResetSSOClientID resets all changes to the "sso_client_id" field.
func (m *AuthConfigMutation) ResetSSOClientID() {
	m.sso_client_id = nil
}

// SetSSOClientSecret sets the "sso_client_secret" field.
func (m *AuthConfigMutation) SetSSOClientSecret(s string) {
	m.sso_client_secret = &s
}

// SSOClientSecret returns the value of the "sso_client_secret" field in the mutation.
func (m *AuthConfigMutation) SSOClientSecret() (r string, exists bool) {
	v := m.sso_client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSSOClientSecret returns the old "sso_client_secret" field's value of the AuthConfig entity.
// If the AuthConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthConfigMutation) OldSSOClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSSOClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSSOClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSOClientSecret: %w", err)
	}
	return oldValue.SSOClientSecret, nil
}

// ResetSSOClientSecret resets all changes to the "sso_client_secret" field.
func (m *AuthConfigMutation) ResetSSOClientSecret() {
	m.sso_client_secret = nil
}

// SetSSORedirectURI sets the "sso_redirect_uri" field.
func (m *AuthConfigMutation) SetSSORedirectURI(s string) {
	m.sso_redirect_uri = &s
}

// SSORedirectURI returns the value of the "sso_redirect_uri" field in the mutation.
func (m *AuthConfigMutation) SSORedirectURI() (r string, exists bool) {
	v := m.sso_redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldSSORedirectURI returns the old "sso_redirect_uri" field's value of the AuthConfig entity.
// If the AuthConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthConfigMutation) OldSSORedirectURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSSORedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSSORedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSORedirectURI: %w", err)
	}
	return oldValue.SSORedirectURI, nil
}

// ResetSSORedirectURI resets all changes to the "sso_redirect_uri" field.
func (m *AuthConfigMutation) ResetSSORedirectURI() {
	m.sso_redirect_uri = nil
}

// SetSSOAuthorizationURL sets the "sso_authorization_url" field.
func (m *AuthConfigMutation) SetSSOAuthorizationURL(s string) {
	m.sso_authorization_url = &s
}

// SSOAuthorizationURL returns the value of the "sso_authorization_url" field in the mutation.
func (m *AuthConfigMutation) SSOAuthorizationURL() (r string, exists bool) {
	v := m.sso_authorization_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSSOAuthorizationURL returns the old "sso_authorization_url" field's value of the AuthConfig entity.
// If the AuthConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthConfigMutation) OldSSOAuthorizationURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSSOAuthorizationURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSSOAuthorizationURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSOAuthorizationURL: %w", err)
	}
	return oldValue.SSOAuthorizationURL, nil
}

// ResetSSOAuthorizationURL resets all changes to the "sso_authorization_url" field.
func (m *AuthConfigMutation) ResetSSOAuthorizationURL() {
	m.sso_authorization_url = nil
}

// SetSSOTokenURL sets the "sso_token_url" field.
func (m *AuthConfigMutation) SetSSOTokenURL(s string) {
	m.sso_token_url = &s
}

// SSOTokenURL returns the value of the "sso_token_url" field in the mutation.
func (m *AuthConfigMutation) SSOTokenURL() (r string, exists bool) {
	v := m.sso_token_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSSOTokenURL returns the old "sso_token_url" field's value of the AuthConfig entity.
// If the AuthConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthConfigMutation) OldSSOTokenURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSSOTokenURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSSOTokenURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSOTokenURL: %w", err)
	}
	return oldValue.SSOTokenURL, nil
}

// ResetSSOTokenURL resets all changes to the "sso_token_url" field.
func (m *AuthConfigMutation) ResetSSOTokenURL() {
	m.sso_token_url = nil
}

// SetSSOUserInfoURL sets the "sso_user_info_url" field.
func (m *AuthConfigMutation) SetSSOUserInfoURL(s string) {
	m.sso_user_info_url = &s
}

// SSOUserInfoURL returns the value of the "sso_user_info_url" field in the mutation.
func (m *AuthConfigMutation) SSOUserInfoURL() (r string, exists bool) {
	v := m.sso_user_info_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSSOUserInfoURL returns the old "sso_user_info_url" field's value of the AuthConfig entity.
// If the AuthConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthConfigMutation) OldSSOUserInfoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSSOUserInfoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSSOUserInfoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSOUserInfoURL: %w", err)
	}
	return oldValue.SSOUserInfoURL, nil
}

// ResetSSOUserInfoURL resets all changes to the "sso_user_info_url" field.
func (m *AuthConfigMutation) ResetSSOUserInfoURL() {
	m.sso_user_info_url = nil
}

// SetEntraTenantID sets the "entra_tenant_id" field.
func (m *AuthConfigMutation) SetEntraTenantID(s string) {
	m.entra_tenant_id = &s
}

// EntraTenantID returns the value of the "entra_tenant_id" field in the mutation.
func (m *AuthConfigMutation) EntraTenantID() (r string, exists bool) {
	v := m.entra_tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntraTenantID returns the old "entra_tenant_id" field's value of the AuthConfig entity.
// If the AuthConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthConfigMutation) OldEntraTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntraTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntraTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntraTenantID: %w", err)
	}
	return oldValue.EntraTenantID, nil
}

// ResetEntraTenantID resets all changes to the "entra_tenant_id" field.
func (m *AuthConfigMutation) ResetEntraTenantID() {
	m.entra_tenant_id = nil
}

// SetGoogleAllowedDomains sets the "google_allowed_domains" field.
func (m *AuthConfigMutation) SetGoogleAllowedDomains(s string) {
	m.google_allowed_domains = &s
}

// GoogleAllowedDomains returns the value of the "google_allowed_domains" field in the mutation.
func (m *AuthConfigMutation) GoogleAllowedDomains() (r string, exists bool) {
	v := m.google_allowed_domains
	if v == nil {
		return
	}
	return *v, true
}

// OldGoogleAllowedDomains returns the old "google_allowed_domains" field's value of the AuthConfig entity.
// If the AuthConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthConfigMutation) OldGoogleAllowedDomains(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoogleAllowedDomains is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoogleAllowedDomains requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoogleAllowedDomains: %w", err)
	}
	return oldValue.GoogleAllowedDomains, nil
}

// ResetGoogleAllowedDomains resets all changes to the "google_allowed_domains" field.
func (m *AuthConfigMutation) ResetGoogleAllowedDomains() {
	m.google_allowed_domains = nil
}

// SetSessionKey sets the "session_key" field.
func (m *AuthConfigMutation) SetSessionKey(b []byte) {
	m.session_key = &b
}

// SessionKey returns the value of the "session_key" field in the mutation.
func (m *AuthConfigMutation) SessionKey() (r []byte, exists bool) {
	v := m.session_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionKey returns the old "session_key" field's value of the AuthConfig entity.
// If the AuthConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthConfigMutation) OldSessionKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionKey: %w", err)
	}
	return oldValue.SessionKey, nil
}

// ResetSessionKey resets all changes to the "session_key" field.
func (m *AuthConfigMutation) ResetSessionKey() {
	m.session_key = nil
}

// Where appends a list predicates to the AuthConfigMutation builder.
func (m *AuthConfigMutation) Where(ps ...predicate.AuthConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthConfig).
func (m *AuthConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthConfigMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.enable_sso != nil {
		fields = append(fields, authconfig.FieldEnableSSO)
	}
	if m.disable_password_login != nil {
		fields = append(fields, authconfig.FieldDisablePasswordLogin)
	}
	if m.sso_provider != nil {
		fields = append(fields, authconfig.FieldSSOProvider)
	}
	if m.sso_client_id != nil {
		fields = append(fields, authconfig.FieldSSOClientID)
	}
	if m.sso_client_secret != nil {
		fields = append(fields, authconfig.FieldSSOClientSecret)
	}
	if m.sso_redirect_uri != nil {
		fields = append(fields, authconfig.FieldSSORedirectURI)
	}
	if m.sso_authorization_url != nil {
		fields = append(fields, authconfig.FieldSSOAuthorizationURL)
	}
	if m.sso_token_url != nil {
		fields = append(fields, authconfig.FieldSSOTokenURL)
	}
	if m.sso_user_info_url != nil {
		fields = append(fields, authconfig.FieldSSOUserInfoURL)
	}
	if m.entra_tenant_id != nil {
		fields = append(fields, authconfig.FieldEntraTenantID)
	}
	if m.google_allowed_domains != nil {
		fields = append(fields, authconfig.FieldGoogleAllowedDomains)
	}
	if m.session_key != nil {
		fields = append(fields, authconfig.FieldSessionKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authconfig.FieldEnableSSO:
		return m.EnableSSO()
	case authconfig.FieldDisablePasswordLogin:
		return m.DisablePasswordLogin()
	case authconfig.FieldSSOProvider:
		return m.SSOProvider()
	case authconfig.FieldSSOClientID:
		return m.SSOClientID()
	case authconfig.FieldSSOClientSecret:
		return m.SSOClientSecret()
	case authconfig.FieldSSORedirectURI:
		return m.SSORedirectURI()
	case authconfig.FieldSSOAuthorizationURL:
		return m.SSOAuthorizationURL()
	case authconfig.FieldSSOTokenURL:
		return m.SSOTokenURL()
	case authconfig.FieldSSOUserInfoURL:
		return m.SSOUserInfoURL()
	case authconfig.FieldEntraTenantID:
		return m.EntraTenantID()
	case authconfig.FieldGoogleAllowedDomains:
		return m.GoogleAllowedDomains()
	case authconfig.FieldSessionKey:
		return m.SessionKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authconfig.FieldEnableSSO:
		return m.OldEnableSSO(ctx)
	case authconfig.FieldDisablePasswordLogin:
		return m.OldDisablePasswordLogin(ctx)
	case authconfig.FieldSSOProvider:
		return m.OldSSOProvider(ctx)
	case authconfig.FieldSSOClientID:
		return m.OldSSOClientID(ctx)
	case authconfig.FieldSSOClientSecret:
		return m.OldSSOClientSecret(ctx)
	case authconfig.FieldSSORedirectURI:
		return m.OldSSORedirectURI(ctx)
	case authconfig.FieldSSOAuthorizationURL:
		return m.OldSSOAuthorizationURL(ctx)
	case authconfig.FieldSSOTokenURL:
		return m.OldSSOTokenURL(ctx)
	case authconfig.FieldSSOUserInfoURL:
		return m.OldSSOUserInfoURL(ctx)
	case authconfig.FieldEntraTenantID:
		return m.OldEntraTenantID(ctx)
	case authconfig.FieldGoogleAllowedDomains:
		return m.OldGoogleAllowedDomains(ctx)
	case authconfig.FieldSessionKey:
		return m.OldSessionKey(ctx)
	}
	return nil, fmt.Errorf("unknown AuthConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authconfig.FieldEnableSSO:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableSSO(v)
		return nil
	case authconfig.FieldDisablePasswordLogin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisablePasswordLogin(v)
		return nil
	case authconfig.FieldSSOProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSOProvider(v)
		return nil
	case authconfig.FieldSSOClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSOClientID(v)
		return nil
	case authconfig.FieldSSOClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSOClientSecret(v)
		return nil
	case authconfig.FieldSSORedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSORedirectURI(v)
		return nil
	case authconfig.FieldSSOAuthorizationURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSOAuthorizationURL(v)
		return nil
	case authconfig.FieldSSOTokenURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSOTokenURL(v)
		return nil
	case authconfig.FieldSSOUserInfoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSOUserInfoURL(v)
		return nil
	case authconfig.FieldEntraTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntraTenantID(v)
		return nil
	case authconfig.FieldGoogleAllowedDomains:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoogleAllowedDomains(v)
		return nil
	case authconfig.FieldSessionKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionKey(v)
		return nil
	}
	return fmt.Errorf("unknown AuthConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthConfigMutation) ResetField(name string) error {
	switch name {
	case authconfig.FieldEnableSSO:
		m.ResetEnableSSO()
		return nil
	case authconfig.FieldDisablePasswordLogin:
		m.ResetDisablePasswordLogin()
		return nil
	case authconfig.FieldSSOProvider:
		m.ResetSSOProvider()
		return nil
	case authconfig.FieldSSOClientID:
		m.ResetSSOClientID()
		return nil
	case authconfig.FieldSSOClientSecret:
		m.ResetSSOClientSecret()
		return nil
	case authconfig.FieldSSORedirectURI:
		m.ResetSSORedirectURI()
		return nil
	case authconfig.FieldSSOAuthorizationURL:
		m.ResetSSOAuthorizationURL()
		return nil
	case authconfig.FieldSSOTokenURL:
		m.ResetSSOTokenURL()
		return nil
	case authconfig.FieldSSOUserInfoURL:
		m.ResetSSOUserInfoURL()
		return nil
	case authconfig.FieldEntraTenantID:
		m.ResetEntraTenantID()
		return nil
	case authconfig.FieldGoogleAllowedDomains:
		m.ResetGoogleAllowedDomains()
		return nil
	case authconfig.FieldSessionKey:
		m.ResetSessionKey()
		return nil
	}
	return fmt.Errorf("unknown AuthConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthConfig edge %s", name)
}

// DataConfigMutation represents an operation that mutates the DataConfig nodes in the graph.
type DataConfigMutation struct {
	config
	op              Op
	typ             string
	id              *int
	days_to_keep    *int
	adddays_to_keep *int
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*DataConfig, error)
	predicates      []predicate.DataConfig
}

var _ ent.Mutation = (*DataConfigMutation)(nil)

// dataconfigOption allows management of the mutation configuration using functional options.
type dataconfigOption func(*DataConfigMutation)

// newDataConfigMutation creates new mutation for the DataConfig entity.
func newDataConfigMutation(c config, op Op, opts ...dataconfigOption) *DataConfigMutation {
	m := &DataConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeDataConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDataConfigID sets the ID field of the mutation.
func withDataConfigID(id int) dataconfigOption {
	return func(m *DataConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *DataConfig
		)
		m.oldValue = func(ctx context.Context) (*DataConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DataConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDataConfig sets the old DataConfig of the mutation.
func withDataConfig(node *DataConfig) dataconfigOption {
	return func(m *DataConfigMutation) {
		m.oldValue = func(context.Context) (*DataConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DataConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DataConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DataConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DataConfigMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DataConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDaysToKeep sets the "days_to_keep" field.
func (m *DataConfigMutation) SetDaysToKeep(i int) {
	m.days_to_keep = &i
	m.adddays_to_keep = nil
}

// DaysToKeep returns the value of the "days_to_keep" field in the mutation.
func (m *DataConfigMutation) DaysToKeep() (r int, exists bool) {
	v := m.days_to_keep
	if v == nil {
		return
	}
	return *v, true
}

// OldDaysToKeep returns the old "days_to_keep" field's value of the DataConfig entity.
// If the DataConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataConfigMutation) OldDaysToKeep(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDaysToKeep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDaysToKeep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDaysToKeep: %w", err)
	}
	return oldValue.DaysToKeep, nil
}

// AddDaysToKeep adds i to the "days_to_keep" field.
func (m *DataConfigMutation) AddDaysToKeep(i int) {
	if m.adddays_to_keep != nil {
		*m.adddays_to_keep += i
	} else {
		m.adddays_to_keep = &i
	}
}

// AddedDaysToKeep returns the value that was added to the "days_to_keep" field in this mutation.
func (m *DataConfigMutation) AddedDaysToKeep() (r int, exists bool) {
	v := m.adddays_to_keep
	if v == nil {
		return
	}
	return *v, true
}

// ResetDaysToKeep resets all changes to the "days_to_keep" field.
func (m *DataConfigMutation) ResetDaysToKeep() {
	m.days_to_keep = nil
	m.adddays_to_keep = nil
}

// Where appends a list predicates to the DataConfigMutation builder.
func (m *DataConfigMutation) Where(ps ...predicate.DataConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DataConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DataConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DataConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DataConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DataConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DataConfig).
func (m *DataConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DataConfigMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.days_to_keep != nil {
		fields = append(fields, dataconfig.FieldDaysToKeep)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DataConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dataconfig.FieldDaysToKeep:
		return m.DaysToKeep()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DataConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dataconfig.FieldDaysToKeep:
		return m.OldDaysToKeep(ctx)
	}
	return nil, fmt.Errorf("unknown DataConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DataConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dataconfig.FieldDaysToKeep:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDaysToKeep(v)
		return nil
	}
	return fmt.Errorf("unknown DataConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DataConfigMutation) AddedFields() []string {
	var fields []string
	if m.adddays_to_keep != nil {
		fields = append(fields, dataconfig.FieldDaysToKeep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DataConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dataconfig.FieldDaysToKeep:
		return m.AddedDaysToKeep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DataConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dataconfig.FieldDaysToKeep:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDaysToKeep(v)
		return nil
	}
	return fmt.Errorf("unknown DataConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DataConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DataConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DataConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DataConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DataConfigMutation) ResetField(name string) error {
	switch name {
	case dataconfig.FieldDaysToKeep:
		m.ResetDaysToKeep()
		return nil
	}
	return fmt.Errorf("unknown DataConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DataConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DataConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DataConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DataConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DataConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DataConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DataConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DataConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DataConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DataConfig edge %s", name)
}

// JobMutation represents an operation that mutates the Job nodes in the graph.
type JobMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int
	name                                *string
	description                         *string
	cron_schedule                       *string
	schedule_enabled                    *bool
	allow_concurrent_runs               *bool
	arguments                           *[]schema.JobArgument
	appendarguments                     []schema.JobArgument
	requires_file_upload                *bool
	average_duration_ms                 *int64
	addaverage_duration_ms              *int64
	timeout_seconds                     *int
	addtimeout_seconds                  *int
	last_edit_time                      *time.Time
	created_at                          *time.Time
	notify_on_start_channel_ids         *[]int
	appendnotify_on_start_channel_ids   []int
	notify_on_success_channel_ids       *[]int
	appendnotify_on_success_channel_ids []int
	notify_on_failure_channel_ids       *[]int
	appendnotify_on_failure_channel_ids []int
	last_run_time                       *time.Time
	next_cron_run_time                  *time.Time
	script                              *string
	last_run_success                    *bool
	created_by_api                      *bool
	clearedFields                       map[string]struct{}
	project                             *int
	clearedproject                      bool
	history                             map[int]struct{}
	removedhistory                      map[int]struct{}
	clearedhistory                      bool
	done                                bool
	oldValue                            func(context.Context) (*Job, error)
	predicates                          []predicate.Job
}

var _ ent.Mutation = (*JobMutation)(nil)

// jobOption allows management of the mutation configuration using functional options.
type jobOption func(*JobMutation)

// newJobMutation creates new mutation for the Job entity.
func newJobMutation(c config, op Op, opts ...jobOption) *JobMutation {
	m := &JobMutation{
		config:        c,
		op:            op,
		typ:           TypeJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobID sets the ID field of the mutation.
func withJobID(id int) jobOption {
	return func(m *JobMutation) {
		var (
			err   error
			once  sync.Once
			value *Job
		)
		m.oldValue = func(ctx context.Context) (*Job, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Job.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJob sets the old Job of the mutation.
func withJob(node *Job) jobOption {
	return func(m *JobMutation) {
		m.oldValue = func(context.Context) (*Job, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Job.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *JobMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *JobMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *JobMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *JobMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *JobMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *JobMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[job.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *JobMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[job.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *JobMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, job.FieldDescription)
}

// SetCronSchedule sets the "cron_schedule" field.
func (m *JobMutation) SetCronSchedule(s string) {
	m.cron_schedule = &s
}

// CronSchedule returns the value of the "cron_schedule" field in the mutation.
func (m *JobMutation) CronSchedule() (r string, exists bool) {
	v := m.cron_schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldCronSchedule returns the old "cron_schedule" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldCronSchedule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCronSchedule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCronSchedule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCronSchedule: %w", err)
	}
	return oldValue.CronSchedule, nil
}

// ClearCronSchedule clears the value of the "cron_schedule" field.
func (m *JobMutation) ClearCronSchedule() {
	m.cron_schedule = nil
	m.clearedFields[job.FieldCronSchedule] = struct{}{}
}

// CronScheduleCleared returns if the "cron_schedule" field was cleared in this mutation.
func (m *JobMutation) CronScheduleCleared() bool {
	_, ok := m.clearedFields[job.FieldCronSchedule]
	return ok
}

// ResetCronSchedule resets all changes to the "cron_schedule" field.
func (m *JobMutation) ResetCronSchedule() {
	m.cron_schedule = nil
	delete(m.clearedFields, job.FieldCronSchedule)
}

// SetScheduleEnabled sets the "schedule_enabled" field.
func (m *JobMutation) SetScheduleEnabled(b bool) {
	m.schedule_enabled = &b
}

// ScheduleEnabled returns the value of the "schedule_enabled" field in the mutation.
func (m *JobMutation) ScheduleEnabled() (r bool, exists bool) {
	v := m.schedule_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduleEnabled returns the old "schedule_enabled" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldScheduleEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduleEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduleEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduleEnabled: %w", err)
	}
	return oldValue.ScheduleEnabled, nil
}

// ResetScheduleEnabled resets all changes to the "schedule_enabled" field.
func (m *JobMutation) ResetScheduleEnabled() {
	m.schedule_enabled = nil
}

// SetAllowConcurrentRuns sets the "allow_concurrent_runs" field.
func (m *JobMutation) SetAllowConcurrentRuns(b bool) {
	m.allow_concurrent_runs = &b
}

// AllowConcurrentRuns returns the value of the "allow_concurrent_runs" field in the mutation.
func (m *JobMutation) AllowConcurrentRuns() (r bool, exists bool) {
	v := m.allow_concurrent_runs
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowConcurrentRuns returns the old "allow_concurrent_runs" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldAllowConcurrentRuns(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowConcurrentRuns is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowConcurrentRuns requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowConcurrentRuns: %w", err)
	}
	return oldValue.AllowConcurrentRuns, nil
}

// ResetAllowConcurrentRuns resets all changes to the "allow_concurrent_runs" field.
func (m *JobMutation) ResetAllowConcurrentRuns() {
	m.allow_concurrent_runs = nil
}

// SetArguments sets the "arguments" field.
func (m *JobMutation) SetArguments(sa []schema.JobArgument) {
	m.arguments = &sa
	m.appendarguments = nil
}

// Arguments returns the value of the "arguments" field in the mutation.
func (m *JobMutation) Arguments() (r []schema.JobArgument, exists bool) {
	v := m.arguments
	if v == nil {
		return
	}
	return *v, true
}

// OldArguments returns the old "arguments" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldArguments(ctx context.Context) (v []schema.JobArgument, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArguments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArguments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArguments: %w", err)
	}
	return oldValue.Arguments, nil
}

// AppendArguments adds sa to the "arguments" field.
func (m *JobMutation) AppendArguments(sa []schema.JobArgument) {
	m.appendarguments = append(m.appendarguments, sa...)
}

// AppendedArguments returns the list of values that were appended to the "arguments" field in this mutation.
func (m *JobMutation) AppendedArguments() ([]schema.JobArgument, bool) {
	if len(m.appendarguments) == 0 {
		return nil, false
	}
	return m.appendarguments, true
}

// ClearArguments clears the value of the "arguments" field.
func (m *JobMutation) ClearArguments() {
	m.arguments = nil
	m.appendarguments = nil
	m.clearedFields[job.FieldArguments] = struct{}{}
}

// ArgumentsCleared returns if the "arguments" field was cleared in this mutation.
func (m *JobMutation) ArgumentsCleared() bool {
	_, ok := m.clearedFields[job.FieldArguments]
	return ok
}

// ResetArguments resets all changes to the "arguments" field.
func (m *JobMutation) ResetArguments() {
	m.arguments = nil
	m.appendarguments = nil
	delete(m.clearedFields, job.FieldArguments)
}

// SetRequiresFileUpload sets the "requires_file_upload" field.
func (m *JobMutation) SetRequiresFileUpload(b bool) {
	m.requires_file_upload = &b
}

// RequiresFileUpload returns the value of the "requires_file_upload" field in the mutation.
func (m *JobMutation) RequiresFileUpload() (r bool, exists bool) {
	v := m.requires_file_upload
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresFileUpload returns the old "requires_file_upload" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldRequiresFileUpload(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresFileUpload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresFileUpload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresFileUpload: %w", err)
	}
	return oldValue.RequiresFileUpload, nil
}

// ResetRequiresFileUpload resets all changes to the "requires_file_upload" field.
func (m *JobMutation) ResetRequiresFileUpload() {
	m.requires_file_upload = nil
}

// SetAverageDurationMs sets the "average_duration_ms" field.
func (m *JobMutation) SetAverageDurationMs(i int64) {
	m.average_duration_ms = &i
	m.addaverage_duration_ms = nil
}

// AverageDurationMs returns the value of the "average_duration_ms" field in the mutation.
func (m *JobMutation) AverageDurationMs() (r int64, exists bool) {
	v := m.average_duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldAverageDurationMs returns the old "average_duration_ms" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldAverageDurationMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAverageDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAverageDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAverageDurationMs: %w", err)
	}
	return oldValue.AverageDurationMs, nil
}

// AddAverageDurationMs adds i to the "average_duration_ms" field.
func (m *JobMutation) AddAverageDurationMs(i int64) {
	if m.addaverage_duration_ms != nil {
		*m.addaverage_duration_ms += i
	} else {
		m.addaverage_duration_ms = &i
	}
}

// AddedAverageDurationMs returns the value that was added to the "average_duration_ms" field in this mutation.
func (m *JobMutation) AddedAverageDurationMs() (r int64, exists bool) {
	v := m.addaverage_duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearAverageDurationMs clears the value of the "average_duration_ms" field.
func (m *JobMutation) ClearAverageDurationMs() {
	m.average_duration_ms = nil
	m.addaverage_duration_ms = nil
	m.clearedFields[job.FieldAverageDurationMs] = struct{}{}
}

// AverageDurationMsCleared returns if the "average_duration_ms" field was cleared in this mutation.
func (m *JobMutation) AverageDurationMsCleared() bool {
	_, ok := m.clearedFields[job.FieldAverageDurationMs]
	return ok
}

// ResetAverageDurationMs resets all changes to the "average_duration_ms" field.
func (m *JobMutation) ResetAverageDurationMs() {
	m.average_duration_ms = nil
	m.addaverage_duration_ms = nil
	delete(m.clearedFields, job.FieldAverageDurationMs)
}

// SetTimeoutSeconds sets the "timeout_seconds" field.
func (m *JobMutation) SetTimeoutSeconds(i int) {
	m.timeout_seconds = &i
	m.addtimeout_seconds = nil
}

// TimeoutSeconds returns the value of the "timeout_seconds" field in the mutation.
func (m *JobMutation) TimeoutSeconds() (r int, exists bool) {
	v := m.timeout_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeoutSeconds returns the old "timeout_seconds" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldTimeoutSeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeoutSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeoutSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeoutSeconds: %w", err)
	}
	return oldValue.TimeoutSeconds, nil
}

// AddTimeoutSeconds adds i to the "timeout_seconds" field.
func (m *JobMutation) AddTimeoutSeconds(i int) {
	if m.addtimeout_seconds != nil {
		*m.addtimeout_seconds += i
	} else {
		m.addtimeout_seconds = &i
	}
}

// AddedTimeoutSeconds returns the value that was added to the "timeout_seconds" field in this mutation.
func (m *JobMutation) AddedTimeoutSeconds() (r int, exists bool) {
	v := m.addtimeout_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearTimeoutSeconds clears the value of the "timeout_seconds" field.
func (m *JobMutation) ClearTimeoutSeconds() {
	m.timeout_seconds = nil
	m.addtimeout_seconds = nil
	m.clearedFields[job.FieldTimeoutSeconds] = struct{}{}
}

// TimeoutSecondsCleared returns if the "timeout_seconds" field was cleared in this mutation.
func (m *JobMutation) TimeoutSecondsCleared() bool {
	_, ok := m.clearedFields[job.FieldTimeoutSeconds]
	return ok
}

// ResetTimeoutSeconds resets all changes to the "timeout_seconds" field.
func (m *JobMutation) ResetTimeoutSeconds() {
	m.timeout_seconds = nil
	m.addtimeout_seconds = nil
	delete(m.clearedFields, job.FieldTimeoutSeconds)
}

// SetLastEditTime sets the "last_edit_time" field.
func (m *JobMutation) SetLastEditTime(t time.Time) {
	m.last_edit_time = &t
}

// LastEditTime returns the value of the "last_edit_time" field in the mutation.
func (m *JobMutation) LastEditTime() (r time.Time, exists bool) {
	v := m.last_edit_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastEditTime returns the old "last_edit_time" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldLastEditTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastEditTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastEditTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastEditTime: %w", err)
	}
	return oldValue.LastEditTime, nil
}

// ResetLastEditTime resets all changes to the "last_edit_time" field.
func (m *JobMutation) ResetLastEditTime() {
	m.last_edit_time = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *JobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetNotifyOnStartChannelIds sets the "notify_on_start_channel_ids" field.
func (m *JobMutation) SetNotifyOnStartChannelIds(i []int) {
	m.notify_on_start_channel_ids = &i
	m.appendnotify_on_start_channel_ids = nil
}

// NotifyOnStartChannelIds returns the value of the "notify_on_start_channel_ids" field in the mutation.
func (m *JobMutation) NotifyOnStartChannelIds() (r []int, exists bool) {
	v := m.notify_on_start_channel_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyOnStartChannelIds returns the old "notify_on_start_channel_ids" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldNotifyOnStartChannelIds(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyOnStartChannelIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyOnStartChannelIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyOnStartChannelIds: %w", err)
	}
	return oldValue.NotifyOnStartChannelIds, nil
}

// AppendNotifyOnStartChannelIds adds i to the "notify_on_start_channel_ids" field.
func (m *JobMutation) AppendNotifyOnStartChannelIds(i []int) {
	m.appendnotify_on_start_channel_ids = append(m.appendnotify_on_start_channel_ids, i...)
}

// AppendedNotifyOnStartChannelIds returns the list of values that were appended to the "notify_on_start_channel_ids" field in this mutation.
func (m *JobMutation) AppendedNotifyOnStartChannelIds() ([]int, bool) {
	if len(m.appendnotify_on_start_channel_ids) == 0 {
		return nil, false
	}
	return m.appendnotify_on_start_channel_ids, true
}

// ClearNotifyOnStartChannelIds clears the value of the "notify_on_start_channel_ids" field.
func (m *JobMutation) ClearNotifyOnStartChannelIds() {
	m.notify_on_start_channel_ids = nil
	m.appendnotify_on_start_channel_ids = nil
	m.clearedFields[job.FieldNotifyOnStartChannelIds] = struct{}{}
}

// NotifyOnStartChannelIdsCleared returns if the "notify_on_start_channel_ids" field was cleared in this mutation.
func (m *JobMutation) NotifyOnStartChannelIdsCleared() bool {
	_, ok := m.clearedFields[job.FieldNotifyOnStartChannelIds]
	return ok
}

// ResetNotifyOnStartChannelIds resets all changes to the "notify_on_start_channel_ids" field.
func (m *JobMutation) ResetNotifyOnStartChannelIds() {
	m.notify_on_start_channel_ids = nil
	m.appendnotify_on_start_channel_ids = nil
	delete(m.clearedFields, job.FieldNotifyOnStartChannelIds)
}

// SetNotifyOnSuccessChannelIds sets the "notify_on_success_channel_ids" field.
func (m *JobMutation) SetNotifyOnSuccessChannelIds(i []int) {
	m.notify_on_success_channel_ids = &i
	m.appendnotify_on_success_channel_ids = nil
}

// NotifyOnSuccessChannelIds returns the value of the "notify_on_success_channel_ids" field in the mutation.
func (m *JobMutation) NotifyOnSuccessChannelIds() (r []int, exists bool) {
	v := m.notify_on_success_channel_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyOnSuccessChannelIds returns the old "notify_on_success_channel_ids" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldNotifyOnSuccessChannelIds(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyOnSuccessChannelIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyOnSuccessChannelIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyOnSuccessChannelIds: %w", err)
	}
	return oldValue.NotifyOnSuccessChannelIds, nil
}

// AppendNotifyOnSuccessChannelIds adds i to the "notify_on_success_channel_ids" field.
func (m *JobMutation) AppendNotifyOnSuccessChannelIds(i []int) {
	m.appendnotify_on_success_channel_ids = append(m.appendnotify_on_success_channel_ids, i...)
}

// AppendedNotifyOnSuccessChannelIds returns the list of values that were appended to the "notify_on_success_channel_ids" field in this mutation.
func (m *JobMutation) AppendedNotifyOnSuccessChannelIds() ([]int, bool) {
	if len(m.appendnotify_on_success_channel_ids) == 0 {
		return nil, false
	}
	return m.appendnotify_on_success_channel_ids, true
}

// ClearNotifyOnSuccessChannelIds clears the value of the "notify_on_success_channel_ids" field.
func (m *JobMutation) ClearNotifyOnSuccessChannelIds() {
	m.notify_on_success_channel_ids = nil
	m.appendnotify_on_success_channel_ids = nil
	m.clearedFields[job.FieldNotifyOnSuccessChannelIds] = struct{}{}
}

// NotifyOnSuccessChannelIdsCleared returns if the "notify_on_success_channel_ids" field was cleared in this mutation.
func (m *JobMutation) NotifyOnSuccessChannelIdsCleared() bool {
	_, ok := m.clearedFields[job.FieldNotifyOnSuccessChannelIds]
	return ok
}

// ResetNotifyOnSuccessChannelIds resets all changes to the "notify_on_success_channel_ids" field.
func (m *JobMutation) ResetNotifyOnSuccessChannelIds() {
	m.notify_on_success_channel_ids = nil
	m.appendnotify_on_success_channel_ids = nil
	delete(m.clearedFields, job.FieldNotifyOnSuccessChannelIds)
}

// SetNotifyOnFailureChannelIds sets the "notify_on_failure_channel_ids" field.
func (m *JobMutation) SetNotifyOnFailureChannelIds(i []int) {
	m.notify_on_failure_channel_ids = &i
	m.appendnotify_on_failure_channel_ids = nil
}

// NotifyOnFailureChannelIds returns the value of the "notify_on_failure_channel_ids" field in the mutation.
func (m *JobMutation) NotifyOnFailureChannelIds() (r []int, exists bool) {
	v := m.notify_on_failure_channel_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyOnFailureChannelIds returns the old "notify_on_failure_channel_ids" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldNotifyOnFailureChannelIds(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyOnFailureChannelIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyOnFailureChannelIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyOnFailureChannelIds: %w", err)
	}
	return oldValue.NotifyOnFailureChannelIds, nil
}

// AppendNotifyOnFailureChannelIds adds i to the "notify_on_failure_channel_ids" field.
func (m *JobMutation) AppendNotifyOnFailureChannelIds(i []int) {
	m.appendnotify_on_failure_channel_ids = append(m.appendnotify_on_failure_channel_ids, i...)
}

// AppendedNotifyOnFailureChannelIds returns the list of values that were appended to the "notify_on_failure_channel_ids" field in this mutation.
func (m *JobMutation) AppendedNotifyOnFailureChannelIds() ([]int, bool) {
	if len(m.appendnotify_on_failure_channel_ids) == 0 {
		return nil, false
	}
	return m.appendnotify_on_failure_channel_ids, true
}

// ClearNotifyOnFailureChannelIds clears the value of the "notify_on_failure_channel_ids" field.
func (m *JobMutation) ClearNotifyOnFailureChannelIds() {
	m.notify_on_failure_channel_ids = nil
	m.appendnotify_on_failure_channel_ids = nil
	m.clearedFields[job.FieldNotifyOnFailureChannelIds] = struct{}{}
}

// NotifyOnFailureChannelIdsCleared returns if the "notify_on_failure_channel_ids" field was cleared in this mutation.
func (m *JobMutation) NotifyOnFailureChannelIdsCleared() bool {
	_, ok := m.clearedFields[job.FieldNotifyOnFailureChannelIds]
	return ok
}

// ResetNotifyOnFailureChannelIds resets all changes to the "notify_on_failure_channel_ids" field.
func (m *JobMutation) ResetNotifyOnFailureChannelIds() {
	m.notify_on_failure_channel_ids = nil
	m.appendnotify_on_failure_channel_ids = nil
	delete(m.clearedFields, job.FieldNotifyOnFailureChannelIds)
}

// SetLastRunTime sets the "last_run_time" field.
func (m *JobMutation) SetLastRunTime(t time.Time) {
	m.last_run_time = &t
}

// LastRunTime returns the value of the "last_run_time" field in the mutation.
func (m *JobMutation) LastRunTime() (r time.Time, exists bool) {
	v := m.last_run_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRunTime returns the old "last_run_time" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldLastRunTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRunTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRunTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRunTime: %w", err)
	}
	return oldValue.LastRunTime, nil
}

// ResetLastRunTime resets all changes to the "last_run_time" field.
func (m *JobMutation) ResetLastRunTime() {
	m.last_run_time = nil
}

// SetNextCronRunTime sets the "next_cron_run_time" field.
func (m *JobMutation) SetNextCronRunTime(t time.Time) {
	m.next_cron_run_time = &t
}

// NextCronRunTime returns the value of the "next_cron_run_time" field in the mutation.
func (m *JobMutation) NextCronRunTime() (r time.Time, exists bool) {
	v := m.next_cron_run_time
	if v == nil {
		return
	}
	return *v, true
}

// OldNextCronRunTime returns the old "next_cron_run_time" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldNextCronRunTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextCronRunTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextCronRunTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextCronRunTime: %w", err)
	}
	return oldValue.NextCronRunTime, nil
}

// ResetNextCronRunTime resets all changes to the "next_cron_run_time" field.
func (m *JobMutation) ResetNextCronRunTime() {
	m.next_cron_run_time = nil
}

// SetScript sets the "script" field.
func (m *JobMutation) SetScript(s string) {
	m.script = &s
}

// Script returns the value of the "script" field in the mutation.
func (m *JobMutation) Script() (r string, exists bool) {
	v := m.script
	if v == nil {
		return
	}
	return *v, true
}

// OldScript returns the old "script" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldScript(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScript is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScript requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScript: %w", err)
	}
	return oldValue.Script, nil
}

// ResetScript resets all changes to the "script" field.
func (m *JobMutation) ResetScript() {
	m.script = nil
}

// SetLastRunSuccess sets the "last_run_success" field.
func (m *JobMutation) SetLastRunSuccess(b bool) {
	m.last_run_success = &b
}

// LastRunSuccess returns the value of the "last_run_success" field in the mutation.
func (m *JobMutation) LastRunSuccess() (r bool, exists bool) {
	v := m.last_run_success
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRunSuccess returns the old "last_run_success" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldLastRunSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRunSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRunSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRunSuccess: %w", err)
	}
	return oldValue.LastRunSuccess, nil
}

// ResetLastRunSuccess resets all changes to the "last_run_success" field.
func (m *JobMutation) ResetLastRunSuccess() {
	m.last_run_success = nil
}

// SetCreatedByAPI sets the "created_by_api" field.
func (m *JobMutation) SetCreatedByAPI(b bool) {
	m.created_by_api = &b
}

// CreatedByAPI returns the value of the "created_by_api" field in the mutation.
func (m *JobMutation) CreatedByAPI() (r bool, exists bool) {
	v := m.created_by_api
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByAPI returns the old "created_by_api" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldCreatedByAPI(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByAPI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByAPI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByAPI: %w", err)
	}
	return oldValue.CreatedByAPI, nil
}

// ResetCreatedByAPI resets all changes to the "created_by_api" field.
func (m *JobMutation) ResetCreatedByAPI() {
	m.created_by_api = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *JobMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *JobMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *JobMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *JobMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *JobMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *JobMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddHistoryIDs adds the "history" edge to the JobHistory entity by ids.
func (m *JobMutation) AddHistoryIDs(ids ...int) {
	if m.history == nil {
		m.history = make(map[int]struct{})
	}
	for i := range ids {
		m.history[ids[i]] = struct{}{}
	}
}

// ClearHistory clears the "history" edge to the JobHistory entity.
func (m *JobMutation) ClearHistory() {
	m.clearedhistory = true
}

// HistoryCleared reports if the "history" edge to the JobHistory entity was cleared.
func (m *JobMutation) HistoryCleared() bool {
	return m.clearedhistory
}

// RemoveHistoryIDs removes the "history" edge to the JobHistory entity by IDs.
func (m *JobMutation) RemoveHistoryIDs(ids ...int) {
	if m.removedhistory == nil {
		m.removedhistory = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.history, ids[i])
		m.removedhistory[ids[i]] = struct{}{}
	}
}

// RemovedHistory returns the removed IDs of the "history" edge to the JobHistory entity.
func (m *JobMutation) RemovedHistoryIDs() (ids []int) {
	for id := range m.removedhistory {
		ids = append(ids, id)
	}
	return
}

// HistoryIDs returns the "history" edge IDs in the mutation.
func (m *JobMutation) HistoryIDs() (ids []int) {
	for id := range m.history {
		ids = append(ids, id)
	}
	return
}

// ResetHistory resets all changes to the "history" edge.
func (m *JobMutation) ResetHistory() {
	m.history = nil
	m.clearedhistory = false
	m.removedhistory = nil
}

// Where appends a list predicates to the JobMutation builder.
func (m *JobMutation) Where(ps ...predicate.Job) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Job, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Job).
func (m *JobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.name != nil {
		fields = append(fields, job.FieldName)
	}
	if m.description != nil {
		fields = append(fields, job.FieldDescription)
	}
	if m.cron_schedule != nil {
		fields = append(fields, job.FieldCronSchedule)
	}
	if m.schedule_enabled != nil {
		fields = append(fields, job.FieldScheduleEnabled)
	}
	if m.allow_concurrent_runs != nil {
		fields = append(fields, job.FieldAllowConcurrentRuns)
	}
	if m.arguments != nil {
		fields = append(fields, job.FieldArguments)
	}
	if m.requires_file_upload != nil {
		fields = append(fields, job.FieldRequiresFileUpload)
	}
	if m.average_duration_ms != nil {
		fields = append(fields, job.FieldAverageDurationMs)
	}
	if m.timeout_seconds != nil {
		fields = append(fields, job.FieldTimeoutSeconds)
	}
	if m.last_edit_time != nil {
		fields = append(fields, job.FieldLastEditTime)
	}
	if m.created_at != nil {
		fields = append(fields, job.FieldCreatedAt)
	}
	if m.notify_on_start_channel_ids != nil {
		fields = append(fields, job.FieldNotifyOnStartChannelIds)
	}
	if m.notify_on_success_channel_ids != nil {
		fields = append(fields, job.FieldNotifyOnSuccessChannelIds)
	}
	if m.notify_on_failure_channel_ids != nil {
		fields = append(fields, job.FieldNotifyOnFailureChannelIds)
	}
	if m.last_run_time != nil {
		fields = append(fields, job.FieldLastRunTime)
	}
	if m.next_cron_run_time != nil {
		fields = append(fields, job.FieldNextCronRunTime)
	}
	if m.script != nil {
		fields = append(fields, job.FieldScript)
	}
	if m.last_run_success != nil {
		fields = append(fields, job.FieldLastRunSuccess)
	}
	if m.created_by_api != nil {
		fields = append(fields, job.FieldCreatedByAPI)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case job.FieldName:
		return m.Name()
	case job.FieldDescription:
		return m.Description()
	case job.FieldCronSchedule:
		return m.CronSchedule()
	case job.FieldScheduleEnabled:
		return m.ScheduleEnabled()
	case job.FieldAllowConcurrentRuns:
		return m.AllowConcurrentRuns()
	case job.FieldArguments:
		return m.Arguments()
	case job.FieldRequiresFileUpload:
		return m.RequiresFileUpload()
	case job.FieldAverageDurationMs:
		return m.AverageDurationMs()
	case job.FieldTimeoutSeconds:
		return m.TimeoutSeconds()
	case job.FieldLastEditTime:
		return m.LastEditTime()
	case job.FieldCreatedAt:
		return m.CreatedAt()
	case job.FieldNotifyOnStartChannelIds:
		return m.NotifyOnStartChannelIds()
	case job.FieldNotifyOnSuccessChannelIds:
		return m.NotifyOnSuccessChannelIds()
	case job.FieldNotifyOnFailureChannelIds:
		return m.NotifyOnFailureChannelIds()
	case job.FieldLastRunTime:
		return m.LastRunTime()
	case job.FieldNextCronRunTime:
		return m.NextCronRunTime()
	case job.FieldScript:
		return m.Script()
	case job.FieldLastRunSuccess:
		return m.LastRunSuccess()
	case job.FieldCreatedByAPI:
		return m.CreatedByAPI()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case job.FieldName:
		return m.OldName(ctx)
	case job.FieldDescription:
		return m.OldDescription(ctx)
	case job.FieldCronSchedule:
		return m.OldCronSchedule(ctx)
	case job.FieldScheduleEnabled:
		return m.OldScheduleEnabled(ctx)
	case job.FieldAllowConcurrentRuns:
		return m.OldAllowConcurrentRuns(ctx)
	case job.FieldArguments:
		return m.OldArguments(ctx)
	case job.FieldRequiresFileUpload:
		return m.OldRequiresFileUpload(ctx)
	case job.FieldAverageDurationMs:
		return m.OldAverageDurationMs(ctx)
	case job.FieldTimeoutSeconds:
		return m.OldTimeoutSeconds(ctx)
	case job.FieldLastEditTime:
		return m.OldLastEditTime(ctx)
	case job.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case job.FieldNotifyOnStartChannelIds:
		return m.OldNotifyOnStartChannelIds(ctx)
	case job.FieldNotifyOnSuccessChannelIds:
		return m.OldNotifyOnSuccessChannelIds(ctx)
	case job.FieldNotifyOnFailureChannelIds:
		return m.OldNotifyOnFailureChannelIds(ctx)
	case job.FieldLastRunTime:
		return m.OldLastRunTime(ctx)
	case job.FieldNextCronRunTime:
		return m.OldNextCronRunTime(ctx)
	case job.FieldScript:
		return m.OldScript(ctx)
	case job.FieldLastRunSuccess:
		return m.OldLastRunSuccess(ctx)
	case job.FieldCreatedByAPI:
		return m.OldCreatedByAPI(ctx)
	}
	return nil, fmt.Errorf("unknown Job field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case job.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case job.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case job.FieldCronSchedule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCronSchedule(v)
		return nil
	case job.FieldScheduleEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduleEnabled(v)
		return nil
	case job.FieldAllowConcurrentRuns:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowConcurrentRuns(v)
		return nil
	case job.FieldArguments:
		v, ok := value.([]schema.JobArgument)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArguments(v)
		return nil
	case job.FieldRequiresFileUpload:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresFileUpload(v)
		return nil
	case job.FieldAverageDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAverageDurationMs(v)
		return nil
	case job.FieldTimeoutSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeoutSeconds(v)
		return nil
	case job.FieldLastEditTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastEditTime(v)
		return nil
	case job.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case job.FieldNotifyOnStartChannelIds:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyOnStartChannelIds(v)
		return nil
	case job.FieldNotifyOnSuccessChannelIds:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyOnSuccessChannelIds(v)
		return nil
	case job.FieldNotifyOnFailureChannelIds:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyOnFailureChannelIds(v)
		return nil
	case job.FieldLastRunTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRunTime(v)
		return nil
	case job.FieldNextCronRunTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextCronRunTime(v)
		return nil
	case job.FieldScript:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScript(v)
		return nil
	case job.FieldLastRunSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRunSuccess(v)
		return nil
	case job.FieldCreatedByAPI:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByAPI(v)
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobMutation) AddedFields() []string {
	var fields []string
	if m.addaverage_duration_ms != nil {
		fields = append(fields, job.FieldAverageDurationMs)
	}
	if m.addtimeout_seconds != nil {
		fields = append(fields, job.FieldTimeoutSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case job.FieldAverageDurationMs:
		return m.AddedAverageDurationMs()
	case job.FieldTimeoutSeconds:
		return m.AddedTimeoutSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case job.FieldAverageDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAverageDurationMs(v)
		return nil
	case job.FieldTimeoutSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeoutSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown Job numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(job.FieldDescription) {
		fields = append(fields, job.FieldDescription)
	}
	if m.FieldCleared(job.FieldCronSchedule) {
		fields = append(fields, job.FieldCronSchedule)
	}
	if m.FieldCleared(job.FieldArguments) {
		fields = append(fields, job.FieldArguments)
	}
	if m.FieldCleared(job.FieldAverageDurationMs) {
		fields = append(fields, job.FieldAverageDurationMs)
	}
	if m.FieldCleared(job.FieldTimeoutSeconds) {
		fields = append(fields, job.FieldTimeoutSeconds)
	}
	if m.FieldCleared(job.FieldNotifyOnStartChannelIds) {
		fields = append(fields, job.FieldNotifyOnStartChannelIds)
	}
	if m.FieldCleared(job.FieldNotifyOnSuccessChannelIds) {
		fields = append(fields, job.FieldNotifyOnSuccessChannelIds)
	}
	if m.FieldCleared(job.FieldNotifyOnFailureChannelIds) {
		fields = append(fields, job.FieldNotifyOnFailureChannelIds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobMutation) ClearField(name string) error {
	switch name {
	case job.FieldDescription:
		m.ClearDescription()
		return nil
	case job.FieldCronSchedule:
		m.ClearCronSchedule()
		return nil
	case job.FieldArguments:
		m.ClearArguments()
		return nil
	case job.FieldAverageDurationMs:
		m.ClearAverageDurationMs()
		return nil
	case job.FieldTimeoutSeconds:
		m.ClearTimeoutSeconds()
		return nil
	case job.FieldNotifyOnStartChannelIds:
		m.ClearNotifyOnStartChannelIds()
		return nil
	case job.FieldNotifyOnSuccessChannelIds:
		m.ClearNotifyOnSuccessChannelIds()
		return nil
	case job.FieldNotifyOnFailureChannelIds:
		m.ClearNotifyOnFailureChannelIds()
		return nil
	}
	return fmt.Errorf("unknown Job nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobMutation) ResetField(name string) error {
	switch name {
	case job.FieldName:
		m.ResetName()
		return nil
	case job.FieldDescription:
		m.ResetDescription()
		return nil
	case job.FieldCronSchedule:
		m.ResetCronSchedule()
		return nil
	case job.FieldScheduleEnabled:
		m.ResetScheduleEnabled()
		return nil
	case job.FieldAllowConcurrentRuns:
		m.ResetAllowConcurrentRuns()
		return nil
	case job.FieldArguments:
		m.ResetArguments()
		return nil
	case job.FieldRequiresFileUpload:
		m.ResetRequiresFileUpload()
		return nil
	case job.FieldAverageDurationMs:
		m.ResetAverageDurationMs()
		return nil
	case job.FieldTimeoutSeconds:
		m.ResetTimeoutSeconds()
		return nil
	case job.FieldLastEditTime:
		m.ResetLastEditTime()
		return nil
	case job.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case job.FieldNotifyOnStartChannelIds:
		m.ResetNotifyOnStartChannelIds()
		return nil
	case job.FieldNotifyOnSuccessChannelIds:
		m.ResetNotifyOnSuccessChannelIds()
		return nil
	case job.FieldNotifyOnFailureChannelIds:
		m.ResetNotifyOnFailureChannelIds()
		return nil
	case job.FieldLastRunTime:
		m.ResetLastRunTime()
		return nil
	case job.FieldNextCronRunTime:
		m.ResetNextCronRunTime()
		return nil
	case job.FieldScript:
		m.ResetScript()
		return nil
	case job.FieldLastRunSuccess:
		m.ResetLastRunSuccess()
		return nil
	case job.FieldCreatedByAPI:
		m.ResetCreatedByAPI()
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, job.EdgeProject)
	}
	if m.history != nil {
		edges = append(edges, job.EdgeHistory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case job.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeHistory:
		ids := make([]ent.Value, 0, len(m.history))
		for id := range m.history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedhistory != nil {
		edges = append(edges, job.EdgeHistory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case job.EdgeHistory:
		ids := make([]ent.Value, 0, len(m.removedhistory))
		for id := range m.removedhistory {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, job.EdgeProject)
	}
	if m.clearedhistory {
		edges = append(edges, job.EdgeHistory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobMutation) EdgeCleared(name string) bool {
	switch name {
	case job.EdgeProject:
		return m.clearedproject
	case job.EdgeHistory:
		return m.clearedhistory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobMutation) ClearEdge(name string) error {
	switch name {
	case job.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Job unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobMutation) ResetEdge(name string) error {
	switch name {
	case job.EdgeProject:
		m.ResetProject()
		return nil
	case job.EdgeHistory:
		m.ResetHistory()
		return nil
	}
	return fmt.Errorf("unknown Job edge %s", name)
}

// JobConfigMutation represents an operation that mutates the JobConfig nodes in the graph.
type JobConfigMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	max_concurrent_jobs        *int
	addmax_concurrent_jobs     *int
	default_timeout_seconds    *int
	adddefault_timeout_seconds *int
	clearedFields              map[string]struct{}
	done                       bool
	oldValue                   func(context.Context) (*JobConfig, error)
	predicates                 []predicate.JobConfig
}

var _ ent.Mutation = (*JobConfigMutation)(nil)

// jobconfigOption allows management of the mutation configuration using functional options.
type jobconfigOption func(*JobConfigMutation)

// newJobConfigMutation creates new mutation for the JobConfig entity.
func newJobConfigMutation(c config, op Op, opts ...jobconfigOption) *JobConfigMutation {
	m := &JobConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeJobConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobConfigID sets the ID field of the mutation.
func withJobConfigID(id int) jobconfigOption {
	return func(m *JobConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *JobConfig
		)
		m.oldValue = func(ctx context.Context) (*JobConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobConfig sets the old JobConfig of the mutation.
func withJobConfig(node *JobConfig) jobconfigOption {
	return func(m *JobConfigMutation) {
		m.oldValue = func(context.Context) (*JobConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobConfigMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMaxConcurrentJobs sets the "max_concurrent_jobs" field.
func (m *JobConfigMutation) SetMaxConcurrentJobs(i int) {
	m.max_concurrent_jobs = &i
	m.addmax_concurrent_jobs = nil
}

// MaxConcurrentJobs returns the value of the "max_concurrent_jobs" field in the mutation.
func (m *JobConfigMutation) MaxConcurrentJobs() (r int, exists bool) {
	v := m.max_concurrent_jobs
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxConcurrentJobs returns the old "max_concurrent_jobs" field's value of the JobConfig entity.
// If the JobConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobConfigMutation) OldMaxConcurrentJobs(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxConcurrentJobs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxConcurrentJobs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxConcurrentJobs: %w", err)
	}
	return oldValue.MaxConcurrentJobs, nil
}

// AddMaxConcurrentJobs adds i to the "max_concurrent_jobs" field.
func (m *JobConfigMutation) AddMaxConcurrentJobs(i int) {
	if m.addmax_concurrent_jobs != nil {
		*m.addmax_concurrent_jobs += i
	} else {
		m.addmax_concurrent_jobs = &i
	}
}

// AddedMaxConcurrentJobs returns the value that was added to the "max_concurrent_jobs" field in this mutation.
func (m *JobConfigMutation) AddedMaxConcurrentJobs() (r int, exists bool) {
	v := m.addmax_concurrent_jobs
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxConcurrentJobs resets all changes to the "max_concurrent_jobs" field.
func (m *JobConfigMutation) ResetMaxConcurrentJobs() {
	m.max_concurrent_jobs = nil
	m.addmax_concurrent_jobs = nil
}

// SetDefaultTimeoutSeconds sets the "default_timeout_seconds" field.
func (m *JobConfigMutation) SetDefaultTimeoutSeconds(i int) {
	m.default_timeout_seconds = &i
	m.adddefault_timeout_seconds = nil
}

// DefaultTimeoutSeconds returns the value of the "default_timeout_seconds" field in the mutation.
func (m *JobConfigMutation) DefaultTimeoutSeconds() (r int, exists bool) {
	v := m.default_timeout_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultTimeoutSeconds returns the old "default_timeout_seconds" field's value of the JobConfig entity.
// If the JobConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobConfigMutation) OldDefaultTimeoutSeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultTimeoutSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultTimeoutSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultTimeoutSeconds: %w", err)
	}
	return oldValue.DefaultTimeoutSeconds, nil
}

// AddDefaultTimeoutSeconds adds i to the "default_timeout_seconds" field.
func (m *JobConfigMutation) AddDefaultTimeoutSeconds(i int) {
	if m.adddefault_timeout_seconds != nil {
		*m.adddefault_timeout_seconds += i
	} else {
		m.adddefault_timeout_seconds = &i
	}
}

// AddedDefaultTimeoutSeconds returns the value that was added to the "default_timeout_seconds" field in this mutation.
func (m *JobConfigMutation) AddedDefaultTimeoutSeconds() (r int, exists bool) {
	v := m.adddefault_timeout_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetDefaultTimeoutSeconds resets all changes to the "default_timeout_seconds" field.
func (m *JobConfigMutation) ResetDefaultTimeoutSeconds() {
	m.default_timeout_seconds = nil
	m.adddefault_timeout_seconds = nil
}

// Where appends a list predicates to the JobConfigMutation builder.
func (m *JobConfigMutation) Where(ps ...predicate.JobConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobConfig).
func (m *JobConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobConfigMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.max_concurrent_jobs != nil {
		fields = append(fields, jobconfig.FieldMaxConcurrentJobs)
	}
	if m.default_timeout_seconds != nil {
		fields = append(fields, jobconfig.FieldDefaultTimeoutSeconds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobconfig.FieldMaxConcurrentJobs:
		return m.MaxConcurrentJobs()
	case jobconfig.FieldDefaultTimeoutSeconds:
		return m.DefaultTimeoutSeconds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobconfig.FieldMaxConcurrentJobs:
		return m.OldMaxConcurrentJobs(ctx)
	case jobconfig.FieldDefaultTimeoutSeconds:
		return m.OldDefaultTimeoutSeconds(ctx)
	}
	return nil, fmt.Errorf("unknown JobConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobconfig.FieldMaxConcurrentJobs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxConcurrentJobs(v)
		return nil
	case jobconfig.FieldDefaultTimeoutSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultTimeoutSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown JobConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobConfigMutation) AddedFields() []string {
	var fields []string
	if m.addmax_concurrent_jobs != nil {
		fields = append(fields, jobconfig.FieldMaxConcurrentJobs)
	}
	if m.adddefault_timeout_seconds != nil {
		fields = append(fields, jobconfig.FieldDefaultTimeoutSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case jobconfig.FieldMaxConcurrentJobs:
		return m.AddedMaxConcurrentJobs()
	case jobconfig.FieldDefaultTimeoutSeconds:
		return m.AddedDefaultTimeoutSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case jobconfig.FieldMaxConcurrentJobs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxConcurrentJobs(v)
		return nil
	case jobconfig.FieldDefaultTimeoutSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultTimeoutSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown JobConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown JobConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobConfigMutation) ResetField(name string) error {
	switch name {
	case jobconfig.FieldMaxConcurrentJobs:
		m.ResetMaxConcurrentJobs()
		return nil
	case jobconfig.FieldDefaultTimeoutSeconds:
		m.ResetDefaultTimeoutSeconds()
		return nil
	}
	return fmt.Errorf("unknown JobConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown JobConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown JobConfig edge %s", name)
}

// JobHistoryMutation represents an operation that mutates the JobHistory nodes in the graph.
type JobHistoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	was_successful     *bool
	duration_ms        *int64
	addduration_ms     *int64
	parameters         *[]schema.Parameter
	appendparameters   []schema.Parameter
	output             *string
	exit_code          *int
	addexit_code       *int
	triggered_by_email *string
	triggered_by_id    *int
	addtriggered_by_id *int
	created_at         *time.Time
	status             *string
	trigger            *string
	clearedFields      map[string]struct{}
	project            *int
	clearedproject     bool
	job                *int
	clearedjob         bool
	done               bool
	oldValue           func(context.Context) (*JobHistory, error)
	predicates         []predicate.JobHistory
}

var _ ent.Mutation = (*JobHistoryMutation)(nil)

// jobhistoryOption allows management of the mutation configuration using functional options.
type jobhistoryOption func(*JobHistoryMutation)

// newJobHistoryMutation creates new mutation for the JobHistory entity.
func newJobHistoryMutation(c config, op Op, opts ...jobhistoryOption) *JobHistoryMutation {
	m := &JobHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeJobHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobHistoryID sets the ID field of the mutation.
func withJobHistoryID(id int) jobhistoryOption {
	return func(m *JobHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *JobHistory
		)
		m.oldValue = func(ctx context.Context) (*JobHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobHistory sets the old JobHistory of the mutation.
func withJobHistory(node *JobHistory) jobhistoryOption {
	return func(m *JobHistoryMutation) {
		m.oldValue = func(context.Context) (*JobHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobHistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobHistoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWasSuccessful sets the "was_successful" field.
func (m *JobHistoryMutation) SetWasSuccessful(b bool) {
	m.was_successful = &b
}

// WasSuccessful returns the value of the "was_successful" field in the mutation.
func (m *JobHistoryMutation) WasSuccessful() (r bool, exists bool) {
	v := m.was_successful
	if v == nil {
		return
	}
	return *v, true
}

// OldWasSuccessful returns the old "was_successful" field's value of the JobHistory entity.
// If the JobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobHistoryMutation) OldWasSuccessful(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWasSuccessful is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWasSuccessful requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWasSuccessful: %w", err)
	}
	return oldValue.WasSuccessful, nil
}

// ResetWasSuccessful resets all changes to the "was_successful" field.
func (m *JobHistoryMutation) ResetWasSuccessful() {
	m.was_successful = nil
}

// SetDurationMs sets the "duration_ms" field.
func (m *JobHistoryMutation) SetDurationMs(i int64) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *JobHistoryMutation) DurationMs() (r int64, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the JobHistory entity.
// If the JobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobHistoryMutation) OldDurationMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *JobHistoryMutation) AddDurationMs(i int64) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *JobHistoryMutation) AddedDurationMs() (r int64, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *JobHistoryMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
}

// SetParameters sets the "parameters" field.
func (m *JobHistoryMutation) SetParameters(s []schema.Parameter) {
	m.parameters = &s
	m.appendparameters = nil
}

// Parameters returns the value of the "parameters" field in the mutation.
func (m *JobHistoryMutation) Parameters() (r []schema.Parameter, exists bool) {
	v := m.parameters
	if v == nil {
		return
	}
	return *v, true
}

// OldParameters returns the old "parameters" field's value of the JobHistory entity.
// If the JobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobHistoryMutation) OldParameters(ctx context.Context) (v []schema.Parameter, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParameters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParameters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParameters: %w", err)
	}
	return oldValue.Parameters, nil
}

// AppendParameters adds s to the "parameters" field.
func (m *JobHistoryMutation) AppendParameters(s []schema.Parameter) {
	m.appendparameters = append(m.appendparameters, s...)
}

// AppendedParameters returns the list of values that were appended to the "parameters" field in this mutation.
func (m *JobHistoryMutation) AppendedParameters() ([]schema.Parameter, bool) {
	if len(m.appendparameters) == 0 {
		return nil, false
	}
	return m.appendparameters, true
}

// ClearParameters clears the value of the "parameters" field.
func (m *JobHistoryMutation) ClearParameters() {
	m.parameters = nil
	m.appendparameters = nil
	m.clearedFields[jobhistory.FieldParameters] = struct{}{}
}

// ParametersCleared returns if the "parameters" field was cleared in this mutation.
func (m *JobHistoryMutation) ParametersCleared() bool {
	_, ok := m.clearedFields[jobhistory.FieldParameters]
	return ok
}

// ResetParameters resets all changes to the "parameters" field.
func (m *JobHistoryMutation) ResetParameters() {
	m.parameters = nil
	m.appendparameters = nil
	delete(m.clearedFields, jobhistory.FieldParameters)
}

// SetOutput sets the "output" field.
func (m *JobHistoryMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *JobHistoryMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the JobHistory entity.
// If the JobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobHistoryMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ResetOutput resets all changes to the "output" field.
func (m *JobHistoryMutation) ResetOutput() {
	m.output = nil
}

// SetExitCode sets the "exit_code" field.
func (m *JobHistoryMutation) SetExitCode(i int) {
	m.exit_code = &i
	m.addexit_code = nil
}

// ExitCode returns the value of the "exit_code" field in the mutation.
func (m *JobHistoryMutation) ExitCode() (r int, exists bool) {
	v := m.exit_code
	if v == nil {
		return
	}
	return *v, true
}

// OldExitCode returns the old "exit_code" field's value of the JobHistory entity.
// If the JobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobHistoryMutation) OldExitCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExitCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExitCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExitCode: %w", err)
	}
	return oldValue.ExitCode, nil
}

// AddExitCode adds i to the "exit_code" field.
func (m *JobHistoryMutation) AddExitCode(i int) {
	if m.addexit_code != nil {
		*m.addexit_code += i
	} else {
		m.addexit_code = &i
	}
}

// AddedExitCode returns the value that was added to the "exit_code" field in this mutation.
func (m *JobHistoryMutation) AddedExitCode() (r int, exists bool) {
	v := m.addexit_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetExitCode resets all changes to the "exit_code" field.
func (m *JobHistoryMutation) ResetExitCode() {
	m.exit_code = nil
	m.addexit_code = nil
}

// SetTriggeredByEmail sets the "triggered_by_email" field.
func (m *JobHistoryMutation) SetTriggeredByEmail(s string) {
	m.triggered_by_email = &s
}

// TriggeredByEmail returns the value of the "triggered_by_email" field in the mutation.
func (m *JobHistoryMutation) TriggeredByEmail() (r string, exists bool) {
	v := m.triggered_by_email
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggeredByEmail returns the old "triggered_by_email" field's value of the JobHistory entity.
// If the JobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobHistoryMutation) OldTriggeredByEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggeredByEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggeredByEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggeredByEmail: %w", err)
	}
	return oldValue.TriggeredByEmail, nil
}

// ResetTriggeredByEmail resets all changes to the "triggered_by_email" field.
func (m *JobHistoryMutation) ResetTriggeredByEmail() {
	m.triggered_by_email = nil
}

// SetTriggeredByID sets the "triggered_by_id" field.
func (m *JobHistoryMutation) SetTriggeredByID(i int) {
	m.triggered_by_id = &i
	m.addtriggered_by_id = nil
}

// TriggeredByID returns the value of the "triggered_by_id" field in the mutation.
func (m *JobHistoryMutation) TriggeredByID() (r int, exists bool) {
	v := m.triggered_by_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggeredByID returns the old "triggered_by_id" field's value of the JobHistory entity.
// If the JobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobHistoryMutation) OldTriggeredByID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggeredByID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggeredByID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggeredByID: %w", err)
	}
	return oldValue.TriggeredByID, nil
}

// AddTriggeredByID adds i to the "triggered_by_id" field.
func (m *JobHistoryMutation) AddTriggeredByID(i int) {
	if m.addtriggered_by_id != nil {
		*m.addtriggered_by_id += i
	} else {
		m.addtriggered_by_id = &i
	}
}

// AddedTriggeredByID returns the value that was added to the "triggered_by_id" field in this mutation.
func (m *JobHistoryMutation) AddedTriggeredByID() (r int, exists bool) {
	v := m.addtriggered_by_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTriggeredByID resets all changes to the "triggered_by_id" field.
func (m *JobHistoryMutation) ResetTriggeredByID() {
	m.triggered_by_id = nil
	m.addtriggered_by_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *JobHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobHistory entity.
// If the JobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetStatus sets the "status" field.
func (m *JobHistoryMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *JobHistoryMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the JobHistory entity.
// If the JobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobHistoryMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *JobHistoryMutation) ResetStatus() {
	m.status = nil
}

// SetTrigger sets the "trigger" field.
func (m *JobHistoryMutation) SetTrigger(s string) {
	m.trigger = &s
}

// Trigger returns the value of the "trigger" field in the mutation.
func (m *JobHistoryMutation) Trigger() (r string, exists bool) {
	v := m.trigger
	if v == nil {
		return
	}
	return *v, true
}

// OldTrigger returns the old "trigger" field's value of the JobHistory entity.
// If the JobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobHistoryMutation) OldTrigger(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrigger is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrigger requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrigger: %w", err)
	}
	return oldValue.Trigger, nil
}

// ResetTrigger resets all changes to the "trigger" field.
func (m *JobHistoryMutation) ResetTrigger() {
	m.trigger = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *JobHistoryMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *JobHistoryMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *JobHistoryMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *JobHistoryMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *JobHistoryMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *JobHistoryMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetJobID sets the "job" edge to the Job entity by id.
func (m *JobHistoryMutation) SetJobID(id int) {
	m.job = &id
}

// ClearJob clears the "job" edge to the Job entity.
func (m *JobHistoryMutation) ClearJob() {
	m.clearedjob = true
}

// JobCleared reports if the "job" edge to the Job entity was cleared.
func (m *JobHistoryMutation) JobCleared() bool {
	return m.clearedjob
}

// JobID returns the "job" edge ID in the mutation.
func (m *JobHistoryMutation) JobID() (id int, exists bool) {
	if m.job != nil {
		return *m.job, true
	}
	return
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *JobHistoryMutation) JobIDs() (ids []int) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *JobHistoryMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// Where appends a list predicates to the JobHistoryMutation builder.
func (m *JobHistoryMutation) Where(ps ...predicate.JobHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobHistory).
func (m *JobHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobHistoryMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.was_successful != nil {
		fields = append(fields, jobhistory.FieldWasSuccessful)
	}
	if m.duration_ms != nil {
		fields = append(fields, jobhistory.FieldDurationMs)
	}
	if m.parameters != nil {
		fields = append(fields, jobhistory.FieldParameters)
	}
	if m.output != nil {
		fields = append(fields, jobhistory.FieldOutput)
	}
	if m.exit_code != nil {
		fields = append(fields, jobhistory.FieldExitCode)
	}
	if m.triggered_by_email != nil {
		fields = append(fields, jobhistory.FieldTriggeredByEmail)
	}
	if m.triggered_by_id != nil {
		fields = append(fields, jobhistory.FieldTriggeredByID)
	}
	if m.created_at != nil {
		fields = append(fields, jobhistory.FieldCreatedAt)
	}
	if m.status != nil {
		fields = append(fields, jobhistory.FieldStatus)
	}
	if m.trigger != nil {
		fields = append(fields, jobhistory.FieldTrigger)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobhistory.FieldWasSuccessful:
		return m.WasSuccessful()
	case jobhistory.FieldDurationMs:
		return m.DurationMs()
	case jobhistory.FieldParameters:
		return m.Parameters()
	case jobhistory.FieldOutput:
		return m.Output()
	case jobhistory.FieldExitCode:
		return m.ExitCode()
	case jobhistory.FieldTriggeredByEmail:
		return m.TriggeredByEmail()
	case jobhistory.FieldTriggeredByID:
		return m.TriggeredByID()
	case jobhistory.FieldCreatedAt:
		return m.CreatedAt()
	case jobhistory.FieldStatus:
		return m.Status()
	case jobhistory.FieldTrigger:
		return m.Trigger()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobhistory.FieldWasSuccessful:
		return m.OldWasSuccessful(ctx)
	case jobhistory.FieldDurationMs:
		return m.OldDurationMs(ctx)
	case jobhistory.FieldParameters:
		return m.OldParameters(ctx)
	case jobhistory.FieldOutput:
		return m.OldOutput(ctx)
	case jobhistory.FieldExitCode:
		return m.OldExitCode(ctx)
	case jobhistory.FieldTriggeredByEmail:
		return m.OldTriggeredByEmail(ctx)
	case jobhistory.FieldTriggeredByID:
		return m.OldTriggeredByID(ctx)
	case jobhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobhistory.FieldStatus:
		return m.OldStatus(ctx)
	case jobhistory.FieldTrigger:
		return m.OldTrigger(ctx)
	}
	return nil, fmt.Errorf("unknown JobHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobhistory.FieldWasSuccessful:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWasSuccessful(v)
		return nil
	case jobhistory.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	case jobhistory.FieldParameters:
		v, ok := value.([]schema.Parameter)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParameters(v)
		return nil
	case jobhistory.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case jobhistory.FieldExitCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExitCode(v)
		return nil
	case jobhistory.FieldTriggeredByEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggeredByEmail(v)
		return nil
	case jobhistory.FieldTriggeredByID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggeredByID(v)
		return nil
	case jobhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobhistory.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case jobhistory.FieldTrigger:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrigger(v)
		return nil
	}
	return fmt.Errorf("unknown JobHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addduration_ms != nil {
		fields = append(fields, jobhistory.FieldDurationMs)
	}
	if m.addexit_code != nil {
		fields = append(fields, jobhistory.FieldExitCode)
	}
	if m.addtriggered_by_id != nil {
		fields = append(fields, jobhistory.FieldTriggeredByID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case jobhistory.FieldDurationMs:
		return m.AddedDurationMs()
	case jobhistory.FieldExitCode:
		return m.AddedExitCode()
	case jobhistory.FieldTriggeredByID:
		return m.AddedTriggeredByID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case jobhistory.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	case jobhistory.FieldExitCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExitCode(v)
		return nil
	case jobhistory.FieldTriggeredByID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTriggeredByID(v)
		return nil
	}
	return fmt.Errorf("unknown JobHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobhistory.FieldParameters) {
		fields = append(fields, jobhistory.FieldParameters)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobHistoryMutation) ClearField(name string) error {
	switch name {
	case jobhistory.FieldParameters:
		m.ClearParameters()
		return nil
	}
	return fmt.Errorf("unknown JobHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobHistoryMutation) ResetField(name string) error {
	switch name {
	case jobhistory.FieldWasSuccessful:
		m.ResetWasSuccessful()
		return nil
	case jobhistory.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	case jobhistory.FieldParameters:
		m.ResetParameters()
		return nil
	case jobhistory.FieldOutput:
		m.ResetOutput()
		return nil
	case jobhistory.FieldExitCode:
		m.ResetExitCode()
		return nil
	case jobhistory.FieldTriggeredByEmail:
		m.ResetTriggeredByEmail()
		return nil
	case jobhistory.FieldTriggeredByID:
		m.ResetTriggeredByID()
		return nil
	case jobhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case jobhistory.FieldTrigger:
		m.ResetTrigger()
		return nil
	}
	return fmt.Errorf("unknown JobHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, jobhistory.EdgeProject)
	}
	if m.job != nil {
		edges = append(edges, jobhistory.EdgeJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobhistory.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case jobhistory.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, jobhistory.EdgeProject)
	}
	if m.clearedjob {
		edges = append(edges, jobhistory.EdgeJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case jobhistory.EdgeProject:
		return m.clearedproject
	case jobhistory.EdgeJob:
		return m.clearedjob
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobHistoryMutation) ClearEdge(name string) error {
	switch name {
	case jobhistory.EdgeProject:
		m.ClearProject()
		return nil
	case jobhistory.EdgeJob:
		m.ClearJob()
		return nil
	}
	return fmt.Errorf("unknown JobHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobHistoryMutation) ResetEdge(name string) error {
	switch name {
	case jobhistory.EdgeProject:
		m.ResetProject()
		return nil
	case jobhistory.EdgeJob:
		m.ResetJob()
		return nil
	}
	return fmt.Errorf("unknown JobHistory edge %s", name)
}

// NotificationChannelMutation represents an operation that mutates the NotificationChannel nodes in the graph.
type NotificationChannelMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	description    *string
	_type          *schema.NotificationChannelType
	_config        *schema.ChannelConfig
	created_at     *time.Time
	updated_at     *time.Time
	enabled        *bool
	retry_count    *int
	addretry_count *int
	last_used      *time.Time
	last_error     *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*NotificationChannel, error)
	predicates     []predicate.NotificationChannel
}

var _ ent.Mutation = (*NotificationChannelMutation)(nil)

// notificationchannelOption allows management of the mutation configuration using functional options.
type notificationchannelOption func(*NotificationChannelMutation)

// newNotificationChannelMutation creates new mutation for the NotificationChannel entity.
func newNotificationChannelMutation(c config, op Op, opts ...notificationchannelOption) *NotificationChannelMutation {
	m := &NotificationChannelMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationChannelID sets the ID field of the mutation.
func withNotificationChannelID(id int) notificationchannelOption {
	return func(m *NotificationChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationChannel
		)
		m.oldValue = func(ctx context.Context) (*NotificationChannel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationChannel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationChannel sets the old NotificationChannel of the mutation.
func withNotificationChannel(node *NotificationChannel) notificationchannelOption {
	return func(m *NotificationChannelMutation) {
		m.oldValue = func(context.Context) (*NotificationChannel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationChannelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationChannelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationChannel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *NotificationChannelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotificationChannelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotificationChannelMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *NotificationChannelMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NotificationChannelMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *NotificationChannelMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[notificationchannel.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *NotificationChannelMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[notificationchannel.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *NotificationChannelMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, notificationchannel.FieldDescription)
}

// SetType sets the "type" field.
func (m *NotificationChannelMutation) SetType(sct schema.NotificationChannelType) {
	m._type = &sct
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationChannelMutation) GetType() (r schema.NotificationChannelType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldType(ctx context.Context) (v schema.NotificationChannelType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationChannelMutation) ResetType() {
	m._type = nil
}

// SetConfig sets the "config" field.
func (m *NotificationChannelMutation) SetConfig(sc schema.ChannelConfig) {
	m._config = &sc
}

// Config returns the value of the "config" field in the mutation.
func (m *NotificationChannelMutation) Config() (r schema.ChannelConfig, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldConfig(ctx context.Context) (v schema.ChannelConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *NotificationChannelMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[notificationchannel.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *NotificationChannelMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[notificationchannel.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *NotificationChannelMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, notificationchannel.FieldConfig)
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationChannelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationChannelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationChannelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationChannelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationChannelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationChannelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEnabled sets the "enabled" field.
func (m *NotificationChannelMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *NotificationChannelMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *NotificationChannelMutation) ResetEnabled() {
	m.enabled = nil
}

// SetRetryCount sets the "retry_count" field.
func (m *NotificationChannelMutation) SetRetryCount(i int) {
	m.retry_count = &i
	m.addretry_count = nil
}

// RetryCount returns the value of the "retry_count" field in the mutation.
func (m *NotificationChannelMutation) RetryCount() (r int, exists bool) {
	v := m.retry_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryCount returns the old "retry_count" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldRetryCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryCount: %w", err)
	}
	return oldValue.RetryCount, nil
}

// AddRetryCount adds i to the "retry_count" field.
func (m *NotificationChannelMutation) AddRetryCount(i int) {
	if m.addretry_count != nil {
		*m.addretry_count += i
	} else {
		m.addretry_count = &i
	}
}

// AddedRetryCount returns the value that was added to the "retry_count" field in this mutation.
func (m *NotificationChannelMutation) AddedRetryCount() (r int, exists bool) {
	v := m.addretry_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearRetryCount clears the value of the "retry_count" field.
func (m *NotificationChannelMutation) ClearRetryCount() {
	m.retry_count = nil
	m.addretry_count = nil
	m.clearedFields[notificationchannel.FieldRetryCount] = struct{}{}
}

// RetryCountCleared returns if the "retry_count" field was cleared in this mutation.
func (m *NotificationChannelMutation) RetryCountCleared() bool {
	_, ok := m.clearedFields[notificationchannel.FieldRetryCount]
	return ok
}

// ResetRetryCount resets all changes to the "retry_count" field.
func (m *NotificationChannelMutation) ResetRetryCount() {
	m.retry_count = nil
	m.addretry_count = nil
	delete(m.clearedFields, notificationchannel.FieldRetryCount)
}

// SetLastUsed sets the "last_used" field.
func (m *NotificationChannelMutation) SetLastUsed(t time.Time) {
	m.last_used = &t
}

// LastUsed returns the value of the "last_used" field in the mutation.
func (m *NotificationChannelMutation) LastUsed() (r time.Time, exists bool) {
	v := m.last_used
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsed returns the old "last_used" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldLastUsed(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsed: %w", err)
	}
	return oldValue.LastUsed, nil
}

// ClearLastUsed clears the value of the "last_used" field.
func (m *NotificationChannelMutation) ClearLastUsed() {
	m.last_used = nil
	m.clearedFields[notificationchannel.FieldLastUsed] = struct{}{}
}

// LastUsedCleared returns if the "last_used" field was cleared in this mutation.
func (m *NotificationChannelMutation) LastUsedCleared() bool {
	_, ok := m.clearedFields[notificationchannel.FieldLastUsed]
	return ok
}

// ResetLastUsed resets all changes to the "last_used" field.
func (m *NotificationChannelMutation) ResetLastUsed() {
	m.last_used = nil
	delete(m.clearedFields, notificationchannel.FieldLastUsed)
}

// SetLastError sets the "last_error" field.
func (m *NotificationChannelMutation) SetLastError(s string) {
	m.last_error = &s
}

// LastError returns the value of the "last_error" field in the mutation.
func (m *NotificationChannelMutation) LastError() (r string, exists bool) {
	v := m.last_error
	if v == nil {
		return
	}
	return *v, true
}

// OldLastError returns the old "last_error" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldLastError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastError: %w", err)
	}
	return oldValue.LastError, nil
}

// ClearLastError clears the value of the "last_error" field.
func (m *NotificationChannelMutation) ClearLastError() {
	m.last_error = nil
	m.clearedFields[notificationchannel.FieldLastError] = struct{}{}
}

// LastErrorCleared returns if the "last_error" field was cleared in this mutation.
func (m *NotificationChannelMutation) LastErrorCleared() bool {
	_, ok := m.clearedFields[notificationchannel.FieldLastError]
	return ok
}

// ResetLastError resets all changes to the "last_error" field.
func (m *NotificationChannelMutation) ResetLastError() {
	m.last_error = nil
	delete(m.clearedFields, notificationchannel.FieldLastError)
}

// Where appends a list predicates to the NotificationChannelMutation builder.
func (m *NotificationChannelMutation) Where(ps ...predicate.NotificationChannel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationChannelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationChannelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationChannel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationChannelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationChannelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationChannel).
func (m *NotificationChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationChannelMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, notificationchannel.FieldName)
	}
	if m.description != nil {
		fields = append(fields, notificationchannel.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, notificationchannel.FieldType)
	}
	if m._config != nil {
		fields = append(fields, notificationchannel.FieldConfig)
	}
	if m.created_at != nil {
		fields = append(fields, notificationchannel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationchannel.FieldUpdatedAt)
	}
	if m.enabled != nil {
		fields = append(fields, notificationchannel.FieldEnabled)
	}
	if m.retry_count != nil {
		fields = append(fields, notificationchannel.FieldRetryCount)
	}
	if m.last_used != nil {
		fields = append(fields, notificationchannel.FieldLastUsed)
	}
	if m.last_error != nil {
		fields = append(fields, notificationchannel.FieldLastError)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationchannel.FieldName:
		return m.Name()
	case notificationchannel.FieldDescription:
		return m.Description()
	case notificationchannel.FieldType:
		return m.GetType()
	case notificationchannel.FieldConfig:
		return m.Config()
	case notificationchannel.FieldCreatedAt:
		return m.CreatedAt()
	case notificationchannel.FieldUpdatedAt:
		return m.UpdatedAt()
	case notificationchannel.FieldEnabled:
		return m.Enabled()
	case notificationchannel.FieldRetryCount:
		return m.RetryCount()
	case notificationchannel.FieldLastUsed:
		return m.LastUsed()
	case notificationchannel.FieldLastError:
		return m.LastError()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationchannel.FieldName:
		return m.OldName(ctx)
	case notificationchannel.FieldDescription:
		return m.OldDescription(ctx)
	case notificationchannel.FieldType:
		return m.OldType(ctx)
	case notificationchannel.FieldConfig:
		return m.OldConfig(ctx)
	case notificationchannel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationchannel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notificationchannel.FieldEnabled:
		return m.OldEnabled(ctx)
	case notificationchannel.FieldRetryCount:
		return m.OldRetryCount(ctx)
	case notificationchannel.FieldLastUsed:
		return m.OldLastUsed(ctx)
	case notificationchannel.FieldLastError:
		return m.OldLastError(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationChannel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationchannel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notificationchannel.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case notificationchannel.FieldType:
		v, ok := value.(schema.NotificationChannelType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notificationchannel.FieldConfig:
		v, ok := value.(schema.ChannelConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case notificationchannel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationchannel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notificationchannel.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case notificationchannel.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryCount(v)
		return nil
	case notificationchannel.FieldLastUsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsed(v)
		return nil
	case notificationchannel.FieldLastError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastError(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationChannelMutation) AddedFields() []string {
	var fields []string
	if m.addretry_count != nil {
		fields = append(fields, notificationchannel.FieldRetryCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationChannelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notificationchannel.FieldRetryCount:
		return m.AddedRetryCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notificationchannel.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetryCount(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationChannelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationchannel.FieldDescription) {
		fields = append(fields, notificationchannel.FieldDescription)
	}
	if m.FieldCleared(notificationchannel.FieldConfig) {
		fields = append(fields, notificationchannel.FieldConfig)
	}
	if m.FieldCleared(notificationchannel.FieldRetryCount) {
		fields = append(fields, notificationchannel.FieldRetryCount)
	}
	if m.FieldCleared(notificationchannel.FieldLastUsed) {
		fields = append(fields, notificationchannel.FieldLastUsed)
	}
	if m.FieldCleared(notificationchannel.FieldLastError) {
		fields = append(fields, notificationchannel.FieldLastError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationChannelMutation) ClearField(name string) error {
	switch name {
	case notificationchannel.FieldDescription:
		m.ClearDescription()
		return nil
	case notificationchannel.FieldConfig:
		m.ClearConfig()
		return nil
	case notificationchannel.FieldRetryCount:
		m.ClearRetryCount()
		return nil
	case notificationchannel.FieldLastUsed:
		m.ClearLastUsed()
		return nil
	case notificationchannel.FieldLastError:
		m.ClearLastError()
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationChannelMutation) ResetField(name string) error {
	switch name {
	case notificationchannel.FieldName:
		m.ResetName()
		return nil
	case notificationchannel.FieldDescription:
		m.ResetDescription()
		return nil
	case notificationchannel.FieldType:
		m.ResetType()
		return nil
	case notificationchannel.FieldConfig:
		m.ResetConfig()
		return nil
	case notificationchannel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationchannel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notificationchannel.FieldEnabled:
		m.ResetEnabled()
		return nil
	case notificationchannel.FieldRetryCount:
		m.ResetRetryCount()
		return nil
	case notificationchannel.FieldLastUsed:
		m.ResetLastUsed()
		return nil
	case notificationchannel.FieldLastError:
		m.ResetLastError()
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationChannelMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationChannelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationChannelMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationChannelMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NotificationChannel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationChannelMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NotificationChannel edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	description         *string
	clearedFields       map[string]struct{}
	projectUsers        map[int]struct{}
	removedprojectUsers map[int]struct{}
	clearedprojectUsers bool
	jobs                map[int]struct{}
	removedjobs         map[int]struct{}
	clearedjobs         bool
	history             map[int]struct{}
	removedhistory      map[int]struct{}
	clearedhistory      bool
	done                bool
	oldValue            func(context.Context) (*Project, error)
	predicates          []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
}

// AddProjectUserIDs adds the "projectUsers" edge to the ProjectUser entity by ids.
func (m *ProjectMutation) AddProjectUserIDs(ids ...int) {
	if m.projectUsers == nil {
		m.projectUsers = make(map[int]struct{})
	}
	for i := range ids {
		m.projectUsers[ids[i]] = struct{}{}
	}
}

// ClearProjectUsers clears the "projectUsers" edge to the ProjectUser entity.
func (m *ProjectMutation) ClearProjectUsers() {
	m.clearedprojectUsers = true
}

// ProjectUsersCleared reports if the "projectUsers" edge to the ProjectUser entity was cleared.
func (m *ProjectMutation) ProjectUsersCleared() bool {
	return m.clearedprojectUsers
}

// RemoveProjectUserIDs removes the "projectUsers" edge to the ProjectUser entity by IDs.
func (m *ProjectMutation) RemoveProjectUserIDs(ids ...int) {
	if m.removedprojectUsers == nil {
		m.removedprojectUsers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projectUsers, ids[i])
		m.removedprojectUsers[ids[i]] = struct{}{}
	}
}

// RemovedProjectUsers returns the removed IDs of the "projectUsers" edge to the ProjectUser entity.
func (m *ProjectMutation) RemovedProjectUsersIDs() (ids []int) {
	for id := range m.removedprojectUsers {
		ids = append(ids, id)
	}
	return
}

// ProjectUsersIDs returns the "projectUsers" edge IDs in the mutation.
func (m *ProjectMutation) ProjectUsersIDs() (ids []int) {
	for id := range m.projectUsers {
		ids = append(ids, id)
	}
	return
}

// ResetProjectUsers resets all changes to the "projectUsers" edge.
func (m *ProjectMutation) ResetProjectUsers() {
	m.projectUsers = nil
	m.clearedprojectUsers = false
	m.removedprojectUsers = nil
}

// AddJobIDs adds the "jobs" edge to the Job entity by ids.
func (m *ProjectMutation) AddJobIDs(ids ...int) {
	if m.jobs == nil {
		m.jobs = make(map[int]struct{})
	}
	for i := range ids {
		m.jobs[ids[i]] = struct{}{}
	}
}

// ClearJobs clears the "jobs" edge to the Job entity.
func (m *ProjectMutation) ClearJobs() {
	m.clearedjobs = true
}

// JobsCleared reports if the "jobs" edge to the Job entity was cleared.
func (m *ProjectMutation) JobsCleared() bool {
	return m.clearedjobs
}

// RemoveJobIDs removes the "jobs" edge to the Job entity by IDs.
func (m *ProjectMutation) RemoveJobIDs(ids ...int) {
	if m.removedjobs == nil {
		m.removedjobs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.jobs, ids[i])
		m.removedjobs[ids[i]] = struct{}{}
	}
}

// RemovedJobs returns the removed IDs of the "jobs" edge to the Job entity.
func (m *ProjectMutation) RemovedJobsIDs() (ids []int) {
	for id := range m.removedjobs {
		ids = append(ids, id)
	}
	return
}

// JobsIDs returns the "jobs" edge IDs in the mutation.
func (m *ProjectMutation) JobsIDs() (ids []int) {
	for id := range m.jobs {
		ids = append(ids, id)
	}
	return
}

// ResetJobs resets all changes to the "jobs" edge.
func (m *ProjectMutation) ResetJobs() {
	m.jobs = nil
	m.clearedjobs = false
	m.removedjobs = nil
}

// AddHistoryIDs adds the "history" edge to the JobHistory entity by ids.
func (m *ProjectMutation) AddHistoryIDs(ids ...int) {
	if m.history == nil {
		m.history = make(map[int]struct{})
	}
	for i := range ids {
		m.history[ids[i]] = struct{}{}
	}
}

// ClearHistory clears the "history" edge to the JobHistory entity.
func (m *ProjectMutation) ClearHistory() {
	m.clearedhistory = true
}

// HistoryCleared reports if the "history" edge to the JobHistory entity was cleared.
func (m *ProjectMutation) HistoryCleared() bool {
	return m.clearedhistory
}

// RemoveHistoryIDs removes the "history" edge to the JobHistory entity by IDs.
func (m *ProjectMutation) RemoveHistoryIDs(ids ...int) {
	if m.removedhistory == nil {
		m.removedhistory = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.history, ids[i])
		m.removedhistory[ids[i]] = struct{}{}
	}
}

// RemovedHistory returns the removed IDs of the "history" edge to the JobHistory entity.
func (m *ProjectMutation) RemovedHistoryIDs() (ids []int) {
	for id := range m.removedhistory {
		ids = append(ids, id)
	}
	return
}

// HistoryIDs returns the "history" edge IDs in the mutation.
func (m *ProjectMutation) HistoryIDs() (ids []int) {
	for id := range m.history {
		ids = append(ids, id)
	}
	return
}

// ResetHistory resets all changes to the "history" edge.
func (m *ProjectMutation) ResetHistory() {
	m.history = nil
	m.clearedhistory = false
	m.removedhistory = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldName:
		return m.Name()
	case project.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.projectUsers != nil {
		edges = append(edges, project.EdgeProjectUsers)
	}
	if m.jobs != nil {
		edges = append(edges, project.EdgeJobs)
	}
	if m.history != nil {
		edges = append(edges, project.EdgeHistory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeProjectUsers:
		ids := make([]ent.Value, 0, len(m.projectUsers))
		for id := range m.projectUsers {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.jobs))
		for id := range m.jobs {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeHistory:
		ids := make([]ent.Value, 0, len(m.history))
		for id := range m.history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedprojectUsers != nil {
		edges = append(edges, project.EdgeProjectUsers)
	}
	if m.removedjobs != nil {
		edges = append(edges, project.EdgeJobs)
	}
	if m.removedhistory != nil {
		edges = append(edges, project.EdgeHistory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeProjectUsers:
		ids := make([]ent.Value, 0, len(m.removedprojectUsers))
		for id := range m.removedprojectUsers {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.removedjobs))
		for id := range m.removedjobs {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeHistory:
		ids := make([]ent.Value, 0, len(m.removedhistory))
		for id := range m.removedhistory {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprojectUsers {
		edges = append(edges, project.EdgeProjectUsers)
	}
	if m.clearedjobs {
		edges = append(edges, project.EdgeJobs)
	}
	if m.clearedhistory {
		edges = append(edges, project.EdgeHistory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeProjectUsers:
		return m.clearedprojectUsers
	case project.EdgeJobs:
		return m.clearedjobs
	case project.EdgeHistory:
		return m.clearedhistory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeProjectUsers:
		m.ResetProjectUsers()
		return nil
	case project.EdgeJobs:
		m.ResetJobs()
		return nil
	case project.EdgeHistory:
		m.ResetHistory()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ProjectUserMutation represents an operation that mutates the ProjectUser nodes in the graph.
type ProjectUserMutation struct {
	config
	op             Op
	typ            string
	id             *int
	can_edit       *bool
	clearedFields  map[string]struct{}
	project        *int
	clearedproject bool
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*ProjectUser, error)
	predicates     []predicate.ProjectUser
}

var _ ent.Mutation = (*ProjectUserMutation)(nil)

// projectuserOption allows management of the mutation configuration using functional options.
type projectuserOption func(*ProjectUserMutation)

// newProjectUserMutation creates new mutation for the ProjectUser entity.
func newProjectUserMutation(c config, op Op, opts ...projectuserOption) *ProjectUserMutation {
	m := &ProjectUserMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectUserID sets the ID field of the mutation.
func withProjectUserID(id int) projectuserOption {
	return func(m *ProjectUserMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectUser
		)
		m.oldValue = func(ctx context.Context) (*ProjectUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectUser sets the old ProjectUser of the mutation.
func withProjectUser(node *ProjectUser) projectuserOption {
	return func(m *ProjectUserMutation) {
		m.oldValue = func(context.Context) (*ProjectUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCanEdit sets the "can_edit" field.
func (m *ProjectUserMutation) SetCanEdit(b bool) {
	m.can_edit = &b
}

// CanEdit returns the value of the "can_edit" field in the mutation.
func (m *ProjectUserMutation) CanEdit() (r bool, exists bool) {
	v := m.can_edit
	if v == nil {
		return
	}
	return *v, true
}

// OldCanEdit returns the old "can_edit" field's value of the ProjectUser entity.
// If the ProjectUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectUserMutation) OldCanEdit(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanEdit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanEdit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanEdit: %w", err)
	}
	return oldValue.CanEdit, nil
}

// ResetCanEdit resets all changes to the "can_edit" field.
func (m *ProjectUserMutation) ResetCanEdit() {
	m.can_edit = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *ProjectUserMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectUserMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectUserMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *ProjectUserMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectUserMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectUserMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ProjectUserMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProjectUserMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProjectUserMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ProjectUserMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProjectUserMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProjectUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ProjectUserMutation builder.
func (m *ProjectUserMutation) Where(ps ...predicate.ProjectUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectUser).
func (m *ProjectUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectUserMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.can_edit != nil {
		fields = append(fields, projectuser.FieldCanEdit)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectuser.FieldCanEdit:
		return m.CanEdit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectuser.FieldCanEdit:
		return m.OldCanEdit(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectuser.FieldCanEdit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanEdit(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectUserMutation) ResetField(name string) error {
	switch name {
	case projectuser.FieldCanEdit:
		m.ResetCanEdit()
		return nil
	}
	return fmt.Errorf("unknown ProjectUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, projectuser.EdgeProject)
	}
	if m.user != nil {
		edges = append(edges, projectuser.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectuser.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case projectuser.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, projectuser.EdgeProject)
	}
	if m.cleareduser {
		edges = append(edges, projectuser.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectUserMutation) EdgeCleared(name string) bool {
	switch name {
	case projectuser.EdgeProject:
		return m.clearedproject
	case projectuser.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectUserMutation) ClearEdge(name string) error {
	switch name {
	case projectuser.EdgeProject:
		m.ClearProject()
		return nil
	case projectuser.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ProjectUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectUserMutation) ResetEdge(name string) error {
	switch name {
	case projectuser.EdgeProject:
		m.ResetProject()
		return nil
	case projectuser.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ProjectUser edge %s", name)
}

// SMTPConfigMutation represents an operation that mutates the SMTPConfig nodes in the graph.
type SMTPConfigMutation struct {
	config
	op            Op
	typ           string
	id            *int
	smtp_server   *string
	smtp_port     *int
	addsmtp_port  *int
	smtp_username *string
	smtp_password *string
	smtp_sender   *string
	smtp_tls      *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SMTPConfig, error)
	predicates    []predicate.SMTPConfig
}

var _ ent.Mutation = (*SMTPConfigMutation)(nil)

// smtpconfigOption allows management of the mutation configuration using functional options.
type smtpconfigOption func(*SMTPConfigMutation)

// newSMTPConfigMutation creates new mutation for the SMTPConfig entity.
func newSMTPConfigMutation(c config, op Op, opts ...smtpconfigOption) *SMTPConfigMutation {
	m := &SMTPConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeSMTPConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSMTPConfigID sets the ID field of the mutation.
func withSMTPConfigID(id int) smtpconfigOption {
	return func(m *SMTPConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *SMTPConfig
		)
		m.oldValue = func(ctx context.Context) (*SMTPConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SMTPConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSMTPConfig sets the old SMTPConfig of the mutation.
func withSMTPConfig(node *SMTPConfig) smtpconfigOption {
	return func(m *SMTPConfigMutation) {
		m.oldValue = func(context.Context) (*SMTPConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SMTPConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SMTPConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SMTPConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SMTPConfigMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SMTPConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSMTPServer sets the "smtp_server" field.
func (m *SMTPConfigMutation) SetSMTPServer(s string) {
	m.smtp_server = &s
}

// SMTPServer returns the value of the "smtp_server" field in the mutation.
func (m *SMTPConfigMutation) SMTPServer() (r string, exists bool) {
	v := m.smtp_server
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPServer returns the old "smtp_server" field's value of the SMTPConfig entity.
// If the SMTPConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMTPConfigMutation) OldSMTPServer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPServer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPServer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPServer: %w", err)
	}
	return oldValue.SMTPServer, nil
}

// ResetSMTPServer resets all changes to the "smtp_server" field.
func (m *SMTPConfigMutation) ResetSMTPServer() {
	m.smtp_server = nil
}

// SetSMTPPort sets the "smtp_port" field.
func (m *SMTPConfigMutation) SetSMTPPort(i int) {
	m.smtp_port = &i
	m.addsmtp_port = nil
}

// SMTPPort returns the value of the "smtp_port" field in the mutation.
func (m *SMTPConfigMutation) SMTPPort() (r int, exists bool) {
	v := m.smtp_port
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPPort returns the old "smtp_port" field's value of the SMTPConfig entity.
// If the SMTPConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMTPConfigMutation) OldSMTPPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPPort: %w", err)
	}
	return oldValue.SMTPPort, nil
}

// AddSMTPPort adds i to the "smtp_port" field.
func (m *SMTPConfigMutation) AddSMTPPort(i int) {
	if m.addsmtp_port != nil {
		*m.addsmtp_port += i
	} else {
		m.addsmtp_port = &i
	}
}

// AddedSMTPPort returns the value that was added to the "smtp_port" field in this mutation.
func (m *SMTPConfigMutation) AddedSMTPPort() (r int, exists bool) {
	v := m.addsmtp_port
	if v == nil {
		return
	}
	return *v, true
}

// ResetSMTPPort resets all changes to the "smtp_port" field.
func (m *SMTPConfigMutation) ResetSMTPPort() {
	m.smtp_port = nil
	m.addsmtp_port = nil
}

// SetSMTPUsername sets the "smtp_username" field.
func (m *SMTPConfigMutation) SetSMTPUsername(s string) {
	m.smtp_username = &s
}

// SMTPUsername returns the value of the "smtp_username" field in the mutation.
func (m *SMTPConfigMutation) SMTPUsername() (r string, exists bool) {
	v := m.smtp_username
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPUsername returns the old "smtp_username" field's value of the SMTPConfig entity.
// If the SMTPConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMTPConfigMutation) OldSMTPUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPUsername: %w", err)
	}
	return oldValue.SMTPUsername, nil
}

// ResetSMTPUsername resets all changes to the "smtp_username" field.
func (m *SMTPConfigMutation) ResetSMTPUsername() {
	m.smtp_username = nil
}

// SetSMTPPassword sets the "smtp_password" field.
func (m *SMTPConfigMutation) SetSMTPPassword(s string) {
	m.smtp_password = &s
}

// SMTPPassword returns the value of the "smtp_password" field in the mutation.
func (m *SMTPConfigMutation) SMTPPassword() (r string, exists bool) {
	v := m.smtp_password
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPPassword returns the old "smtp_password" field's value of the SMTPConfig entity.
// If the SMTPConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMTPConfigMutation) OldSMTPPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPPassword: %w", err)
	}
	return oldValue.SMTPPassword, nil
}

// ResetSMTPPassword resets all changes to the "smtp_password" field.
func (m *SMTPConfigMutation) ResetSMTPPassword() {
	m.smtp_password = nil
}

// SetSMTPSender sets the "smtp_sender" field.
func (m *SMTPConfigMutation) SetSMTPSender(s string) {
	m.smtp_sender = &s
}

// SMTPSender returns the value of the "smtp_sender" field in the mutation.
func (m *SMTPConfigMutation) SMTPSender() (r string, exists bool) {
	v := m.smtp_sender
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPSender returns the old "smtp_sender" field's value of the SMTPConfig entity.
// If the SMTPConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMTPConfigMutation) OldSMTPSender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPSender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPSender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPSender: %w", err)
	}
	return oldValue.SMTPSender, nil
}

// ResetSMTPSender resets all changes to the "smtp_sender" field.
func (m *SMTPConfigMutation) ResetSMTPSender() {
	m.smtp_sender = nil
}

// SetSMTPTLS sets the "smtp_tls" field.
func (m *SMTPConfigMutation) SetSMTPTLS(b bool) {
	m.smtp_tls = &b
}

// SMTPTLS returns the value of the "smtp_tls" field in the mutation.
func (m *SMTPConfigMutation) SMTPTLS() (r bool, exists bool) {
	v := m.smtp_tls
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPTLS returns the old "smtp_tls" field's value of the SMTPConfig entity.
// If the SMTPConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMTPConfigMutation) OldSMTPTLS(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPTLS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPTLS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPTLS: %w", err)
	}
	return oldValue.SMTPTLS, nil
}

// ResetSMTPTLS resets all changes to the "smtp_tls" field.
func (m *SMTPConfigMutation) ResetSMTPTLS() {
	m.smtp_tls = nil
}

// Where appends a list predicates to the SMTPConfigMutation builder.
func (m *SMTPConfigMutation) Where(ps ...predicate.SMTPConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SMTPConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SMTPConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SMTPConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SMTPConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SMTPConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SMTPConfig).
func (m *SMTPConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SMTPConfigMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.smtp_server != nil {
		fields = append(fields, smtpconfig.FieldSMTPServer)
	}
	if m.smtp_port != nil {
		fields = append(fields, smtpconfig.FieldSMTPPort)
	}
	if m.smtp_username != nil {
		fields = append(fields, smtpconfig.FieldSMTPUsername)
	}
	if m.smtp_password != nil {
		fields = append(fields, smtpconfig.FieldSMTPPassword)
	}
	if m.smtp_sender != nil {
		fields = append(fields, smtpconfig.FieldSMTPSender)
	}
	if m.smtp_tls != nil {
		fields = append(fields, smtpconfig.FieldSMTPTLS)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SMTPConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case smtpconfig.FieldSMTPServer:
		return m.SMTPServer()
	case smtpconfig.FieldSMTPPort:
		return m.SMTPPort()
	case smtpconfig.FieldSMTPUsername:
		return m.SMTPUsername()
	case smtpconfig.FieldSMTPPassword:
		return m.SMTPPassword()
	case smtpconfig.FieldSMTPSender:
		return m.SMTPSender()
	case smtpconfig.FieldSMTPTLS:
		return m.SMTPTLS()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SMTPConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case smtpconfig.FieldSMTPServer:
		return m.OldSMTPServer(ctx)
	case smtpconfig.FieldSMTPPort:
		return m.OldSMTPPort(ctx)
	case smtpconfig.FieldSMTPUsername:
		return m.OldSMTPUsername(ctx)
	case smtpconfig.FieldSMTPPassword:
		return m.OldSMTPPassword(ctx)
	case smtpconfig.FieldSMTPSender:
		return m.OldSMTPSender(ctx)
	case smtpconfig.FieldSMTPTLS:
		return m.OldSMTPTLS(ctx)
	}
	return nil, fmt.Errorf("unknown SMTPConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SMTPConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case smtpconfig.FieldSMTPServer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPServer(v)
		return nil
	case smtpconfig.FieldSMTPPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPPort(v)
		return nil
	case smtpconfig.FieldSMTPUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPUsername(v)
		return nil
	case smtpconfig.FieldSMTPPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPPassword(v)
		return nil
	case smtpconfig.FieldSMTPSender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPSender(v)
		return nil
	case smtpconfig.FieldSMTPTLS:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPTLS(v)
		return nil
	}
	return fmt.Errorf("unknown SMTPConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SMTPConfigMutation) AddedFields() []string {
	var fields []string
	if m.addsmtp_port != nil {
		fields = append(fields, smtpconfig.FieldSMTPPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SMTPConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case smtpconfig.FieldSMTPPort:
		return m.AddedSMTPPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SMTPConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case smtpconfig.FieldSMTPPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSMTPPort(v)
		return nil
	}
	return fmt.Errorf("unknown SMTPConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SMTPConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SMTPConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SMTPConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SMTPConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SMTPConfigMutation) ResetField(name string) error {
	switch name {
	case smtpconfig.FieldSMTPServer:
		m.ResetSMTPServer()
		return nil
	case smtpconfig.FieldSMTPPort:
		m.ResetSMTPPort()
		return nil
	case smtpconfig.FieldSMTPUsername:
		m.ResetSMTPUsername()
		return nil
	case smtpconfig.FieldSMTPPassword:
		m.ResetSMTPPassword()
		return nil
	case smtpconfig.FieldSMTPSender:
		m.ResetSMTPSender()
		return nil
	case smtpconfig.FieldSMTPTLS:
		m.ResetSMTPTLS()
		return nil
	}
	return fmt.Errorf("unknown SMTPConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SMTPConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SMTPConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SMTPConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SMTPConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SMTPConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SMTPConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SMTPConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SMTPConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SMTPConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SMTPConfig edge %s", name)
}

// SecretMutation represents an operation that mutates the Secret nodes in the graph.
type SecretMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	value          *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	project        *int
	clearedproject bool
	done           bool
	oldValue       func(context.Context) (*Secret, error)
	predicates     []predicate.Secret
}

var _ ent.Mutation = (*SecretMutation)(nil)

// secretOption allows management of the mutation configuration using functional options.
type secretOption func(*SecretMutation)

// newSecretMutation creates new mutation for the Secret entity.
func newSecretMutation(c config, op Op, opts ...secretOption) *SecretMutation {
	m := &SecretMutation{
		config:        c,
		op:            op,
		typ:           TypeSecret,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSecretID sets the ID field of the mutation.
func withSecretID(id int) secretOption {
	return func(m *SecretMutation) {
		var (
			err   error
			once  sync.Once
			value *Secret
		)
		m.oldValue = func(ctx context.Context) (*Secret, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Secret.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSecret sets the old Secret of the mutation.
func withSecret(node *Secret) secretOption {
	return func(m *SecretMutation) {
		m.oldValue = func(context.Context) (*Secret, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SecretMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SecretMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SecretMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SecretMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Secret.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SecretMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SecretMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SecretMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *SecretMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SecretMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SecretMutation) ResetValue() {
	m.value = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SecretMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SecretMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SecretMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SecretMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SecretMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SecretMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *SecretMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *SecretMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *SecretMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *SecretMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *SecretMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *SecretMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the SecretMutation builder.
func (m *SecretMutation) Where(ps ...predicate.Secret) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SecretMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SecretMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Secret, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SecretMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SecretMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Secret).
func (m *SecretMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SecretMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, secret.FieldName)
	}
	if m.value != nil {
		fields = append(fields, secret.FieldValue)
	}
	if m.created_at != nil {
		fields = append(fields, secret.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, secret.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SecretMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case secret.FieldName:
		return m.Name()
	case secret.FieldValue:
		return m.Value()
	case secret.FieldCreatedAt:
		return m.CreatedAt()
	case secret.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SecretMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case secret.FieldName:
		return m.OldName(ctx)
	case secret.FieldValue:
		return m.OldValue(ctx)
	case secret.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case secret.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Secret field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecretMutation) SetField(name string, value ent.Value) error {
	switch name {
	case secret.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case secret.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case secret.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case secret.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Secret field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SecretMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SecretMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecretMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Secret numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SecretMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SecretMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SecretMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Secret nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SecretMutation) ResetField(name string) error {
	switch name {
	case secret.FieldName:
		m.ResetName()
		return nil
	case secret.FieldValue:
		m.ResetValue()
		return nil
	case secret.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case secret.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Secret field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SecretMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.project != nil {
		edges = append(edges, secret.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SecretMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case secret.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SecretMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SecretMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SecretMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproject {
		edges = append(edges, secret.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SecretMutation) EdgeCleared(name string) bool {
	switch name {
	case secret.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SecretMutation) ClearEdge(name string) error {
	switch name {
	case secret.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Secret unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SecretMutation) ResetEdge(name string) error {
	switch name {
	case secret.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown Secret edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	email                *string
	encrypted_password   *[]byte
	admin                *bool
	created_at           *time.Time
	updated_at           *time.Time
	api_key              *string
	must_change_password *bool
	clearedFields        map[string]struct{}
	projectUsers         map[int]struct{}
	removedprojectUsers  map[int]struct{}
	clearedprojectUsers  bool
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetEncryptedPassword sets the "encrypted_password" field.
func (m *UserMutation) SetEncryptedPassword(b []byte) {
	m.encrypted_password = &b
}

// EncryptedPassword returns the value of the "encrypted_password" field in the mutation.
func (m *UserMutation) EncryptedPassword() (r []byte, exists bool) {
	v := m.encrypted_password
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptedPassword returns the old "encrypted_password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEncryptedPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptedPassword: %w", err)
	}
	return oldValue.EncryptedPassword, nil
}

// ResetEncryptedPassword resets all changes to the "encrypted_password" field.
func (m *UserMutation) ResetEncryptedPassword() {
	m.encrypted_password = nil
}

// SetAdmin sets the "admin" field.
func (m *UserMutation) SetAdmin(b bool) {
	m.admin = &b
}

// Admin returns the value of the "admin" field in the mutation.
func (m *UserMutation) Admin() (r bool, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdmin returns the old "admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdmin: %w", err)
	}
	return oldValue.Admin, nil
}

// ResetAdmin resets all changes to the "admin" field.
func (m *UserMutation) ResetAdmin() {
	m.admin = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAPIKey sets the "api_key" field.
func (m *UserMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *UserMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *UserMutation) ResetAPIKey() {
	m.api_key = nil
}

// SetMustChangePassword sets the "must_change_password" field.
func (m *UserMutation) SetMustChangePassword(b bool) {
	m.must_change_password = &b
}

// MustChangePassword returns the value of the "must_change_password" field in the mutation.
func (m *UserMutation) MustChangePassword() (r bool, exists bool) {
	v := m.must_change_password
	if v == nil {
		return
	}
	return *v, true
}

// OldMustChangePassword returns the old "must_change_password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMustChangePassword(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMustChangePassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMustChangePassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMustChangePassword: %w", err)
	}
	return oldValue.MustChangePassword, nil
}

// ResetMustChangePassword resets all changes to the "must_change_password" field.
func (m *UserMutation) ResetMustChangePassword() {
	m.must_change_password = nil
}

// AddProjectUserIDs adds the "projectUsers" edge to the ProjectUser entity by ids.
func (m *UserMutation) AddProjectUserIDs(ids ...int) {
	if m.projectUsers == nil {
		m.projectUsers = make(map[int]struct{})
	}
	for i := range ids {
		m.projectUsers[ids[i]] = struct{}{}
	}
}

// ClearProjectUsers clears the "projectUsers" edge to the ProjectUser entity.
func (m *UserMutation) ClearProjectUsers() {
	m.clearedprojectUsers = true
}

// ProjectUsersCleared reports if the "projectUsers" edge to the ProjectUser entity was cleared.
func (m *UserMutation) ProjectUsersCleared() bool {
	return m.clearedprojectUsers
}

// RemoveProjectUserIDs removes the "projectUsers" edge to the ProjectUser entity by IDs.
func (m *UserMutation) RemoveProjectUserIDs(ids ...int) {
	if m.removedprojectUsers == nil {
		m.removedprojectUsers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projectUsers, ids[i])
		m.removedprojectUsers[ids[i]] = struct{}{}
	}
}

// RemovedProjectUsers returns the removed IDs of the "projectUsers" edge to the ProjectUser entity.
func (m *UserMutation) RemovedProjectUsersIDs() (ids []int) {
	for id := range m.removedprojectUsers {
		ids = append(ids, id)
	}
	return
}

// ProjectUsersIDs returns the "projectUsers" edge IDs in the mutation.
func (m *UserMutation) ProjectUsersIDs() (ids []int) {
	for id := range m.projectUsers {
		ids = append(ids, id)
	}
	return
}

// ResetProjectUsers resets all changes to the "projectUsers" edge.
func (m *UserMutation) ResetProjectUsers() {
	m.projectUsers = nil
	m.clearedprojectUsers = false
	m.removedprojectUsers = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.encrypted_password != nil {
		fields = append(fields, user.FieldEncryptedPassword)
	}
	if m.admin != nil {
		fields = append(fields, user.FieldAdmin)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.api_key != nil {
		fields = append(fields, user.FieldAPIKey)
	}
	if m.must_change_password != nil {
		fields = append(fields, user.FieldMustChangePassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldEncryptedPassword:
		return m.EncryptedPassword()
	case user.FieldAdmin:
		return m.Admin()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldAPIKey:
		return m.APIKey()
	case user.FieldMustChangePassword:
		return m.MustChangePassword()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldEncryptedPassword:
		return m.OldEncryptedPassword(ctx)
	case user.FieldAdmin:
		return m.OldAdmin(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case user.FieldMustChangePassword:
		return m.OldMustChangePassword(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldEncryptedPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptedPassword(v)
		return nil
	case user.FieldAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdmin(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case user.FieldMustChangePassword:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMustChangePassword(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldEncryptedPassword:
		m.ResetEncryptedPassword()
		return nil
	case user.FieldAdmin:
		m.ResetAdmin()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case user.FieldMustChangePassword:
		m.ResetMustChangePassword()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.projectUsers != nil {
		edges = append(edges, user.EdgeProjectUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeProjectUsers:
		ids := make([]ent.Value, 0, len(m.projectUsers))
		for id := range m.projectUsers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprojectUsers != nil {
		edges = append(edges, user.EdgeProjectUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeProjectUsers:
		ids := make([]ent.Value, 0, len(m.removedprojectUsers))
		for id := range m.removedprojectUsers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprojectUsers {
		edges = append(edges, user.EdgeProjectUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeProjectUsers:
		return m.clearedprojectUsers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeProjectUsers:
		m.ResetProjectUsers()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
